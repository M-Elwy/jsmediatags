{"version":3,"file":"jsmediatags.cjs.production.min.js","sources":["../src/ChunkedFileData.ts","../src/StringUtils.ts","../src/MediaFileReader.ts","../src/XhrFileReader.ts","../src/BlobFileReader.ts","../src/ArrayFileReader.ts","../src/MediaTagReader.ts","../src/ID3v1TagReader.ts","../src/ID3v2FrameReader.ts","../src/ID3v2TagReader.ts","../src/MP4TagReader.ts","../src/FLACTagReader.ts","../src/NodeFileReader.ts","../src/jsmediatags.ts"],"sourcesContent":["/**\r\n * This class represents a file that might not have all its data loaded yet.\r\n * It is used when loading the entire file is not an option because it's too\r\n * expensive. Instead, parts of the file are loaded and added only when needed.\r\n * From a reading point of view is as if the entire file is loaded. The\r\n * exception is when the data is not available yet, an error will be thrown.\r\n * This class does not load the data, it just manages it. It provides operations\r\n * to add and read data from the file.\r\n *\r\n * @flow\r\n */\r\nconst NOT_FOUND = -1;\r\n\r\nimport type { ChunkType, DataType } from \"./FlowTypes\";\r\n\r\nclass ChunkedFileData {\r\n  // $FlowIssue - get/set properties not yet supported\r\n  static get NOT_FOUND() {\r\n    return NOT_FOUND;\r\n  }\r\n  _fileData: Array<ChunkType>;\r\n\r\n  constructor() {\r\n    this._fileData = [];\r\n  }\r\n\r\n  /**\r\n   * Adds data to the file storage at a specific offset.\r\n   */\r\n  addData(offset: number, data: DataType): void {\r\n    var offsetEnd = offset + data.length - 1;\r\n    var chunkRange = this._getChunkRange(offset, offsetEnd);\r\n\r\n    if (chunkRange.startIx === NOT_FOUND) {\r\n      this._fileData.splice(chunkRange.insertIx || 0, 0, {\r\n        offset: offset,\r\n        data: data,\r\n      });\r\n    } else {\r\n      // If the data to add collides with existing chunks we prepend and\r\n      // append data from the half colliding chunks to make the collision at\r\n      // 100%. The new data can then replace all the colliding chunkes.\r\n      var firstChunk = this._fileData[chunkRange.startIx];\r\n      var lastChunk = this._fileData[chunkRange.endIx];\r\n      var needsPrepend = offset > firstChunk.offset;\r\n      var needsAppend =\r\n        offsetEnd < lastChunk.offset + lastChunk.data.length - 1;\r\n\r\n      var chunk = {\r\n        offset: Math.min(offset, firstChunk.offset),\r\n        data: data,\r\n      };\r\n\r\n      if (needsPrepend) {\r\n        var slicedData = this._sliceData(\r\n          firstChunk.data,\r\n          0,\r\n          offset - firstChunk.offset\r\n        );\r\n        chunk.data = this._concatData(slicedData, data);\r\n      }\r\n\r\n      if (needsAppend) {\r\n        // Use the lastChunk because the slice logic is easier to handle.\r\n        var slicedData = this._sliceData(\r\n          chunk.data,\r\n          0,\r\n          lastChunk.offset - chunk.offset\r\n        );\r\n        chunk.data = this._concatData(slicedData, lastChunk.data);\r\n      }\r\n\r\n      this._fileData.splice(\r\n        chunkRange.startIx,\r\n        chunkRange.endIx - chunkRange.startIx + 1,\r\n        chunk\r\n      );\r\n    }\r\n  }\r\n\r\n  _concatData(dataA: DataType, dataB: DataType): DataType {\r\n    // TypedArrays don't support concat.\r\n    if (\r\n      typeof ArrayBuffer !== \"undefined\" &&\r\n      ArrayBuffer.isView &&\r\n      ArrayBuffer.isView(dataA)\r\n    ) {\r\n      // $FlowIssue - flow thinks dataAandB is a string but it's not\r\n      var dataAandB = new dataA.constructor(dataA.length + dataB.length);\r\n      // $FlowIssue - flow thinks dataAandB is a string but it's not\r\n      dataAandB.set(dataA, 0);\r\n      // $FlowIssue - flow thinks dataAandB is a string but it's not\r\n      dataAandB.set(dataB, dataA.length);\r\n      return dataAandB;\r\n    } else {\r\n      // $FlowIssue - flow thinks dataAandB is a TypedArray but it's not\r\n      return dataA.concat(dataB);\r\n    }\r\n  }\r\n\r\n  _sliceData(data: DataType, begin: number, end: number): DataType {\r\n    // Some TypeArray implementations do not support slice yet.\r\n    if (data.slice) {\r\n      return data.slice(begin, end);\r\n    } else {\r\n      // $FlowIssue - flow thinks data is a string but it's not\r\n      return data.subarray(begin, end);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Finds the chunk range that overlaps the [offsetStart-1,offsetEnd+1] range.\r\n   * When a chunk is adjacent to the offset we still consider it part of the\r\n   * range (this is the situation of offsetStart-1 or offsetEnd+1).\r\n   * When no chunks are found `insertIx` denotes the index where the data\r\n   * should be inserted in the data list (startIx == NOT_FOUND and endIX ==\r\n   * NOT_FOUND).\r\n   */\r\n  _getChunkRange(\r\n    offsetStart: number,\r\n    offsetEnd: number\r\n  ): { startIx: number; endIx: number; insertIx?: number } {\r\n    var startChunkIx = NOT_FOUND;\r\n    var endChunkIx = NOT_FOUND;\r\n    var insertIx = 0;\r\n\r\n    // Could use binary search but not expecting that many blocks to exist.\r\n    for (var i = 0; i < this._fileData.length; i++, insertIx = i) {\r\n      var chunkOffsetStart = this._fileData[i].offset;\r\n      var chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.length;\r\n\r\n      if (offsetEnd < chunkOffsetStart - 1) {\r\n        // This offset range doesn't overlap with any chunks.\r\n        break;\r\n      }\r\n      // If it is adjacent we still consider it part of the range because\r\n      // we're going end up with a single block with all contiguous data.\r\n      if (\r\n        offsetStart <= chunkOffsetEnd + 1 &&\r\n        offsetEnd >= chunkOffsetStart - 1\r\n      ) {\r\n        startChunkIx = i;\r\n        break;\r\n      }\r\n    }\r\n\r\n    // No starting chunk was found, meaning that the offset is either before\r\n    // or after the current stored chunks.\r\n    if (startChunkIx === NOT_FOUND) {\r\n      return {\r\n        startIx: NOT_FOUND,\r\n        endIx: NOT_FOUND,\r\n        insertIx: insertIx,\r\n      };\r\n    }\r\n\r\n    // Find the ending chunk.\r\n    for (var i = startChunkIx; i < this._fileData.length; i++) {\r\n      var chunkOffsetStart = this._fileData[i].offset;\r\n      var chunkOffsetEnd = chunkOffsetStart + this._fileData[i].data.length;\r\n\r\n      if (offsetEnd >= chunkOffsetStart - 1) {\r\n        // Candidate for the end chunk, it doesn't mean it is yet.\r\n        endChunkIx = i;\r\n      }\r\n      if (offsetEnd <= chunkOffsetEnd + 1) {\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (endChunkIx === NOT_FOUND) {\r\n      endChunkIx = startChunkIx;\r\n    }\r\n\r\n    return {\r\n      startIx: startChunkIx,\r\n      endIx: endChunkIx,\r\n    };\r\n  }\r\n\r\n  hasDataRange(offsetStart: number, offsetEnd: number): boolean {\r\n    for (var i = 0; i < this._fileData.length; i++) {\r\n      var chunk = this._fileData[i];\r\n      if (offsetEnd < chunk.offset) {\r\n        return false;\r\n      }\r\n\r\n      if (\r\n        offsetStart >= chunk.offset &&\r\n        offsetEnd < chunk.offset + chunk.data.length\r\n      ) {\r\n        return true;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  getByteAt(offset: number): any {\r\n    var dataChunk;\r\n\r\n    for (var i = 0; i < this._fileData.length; i++) {\r\n      var dataChunkStart = this._fileData[i].offset;\r\n      var dataChunkEnd = dataChunkStart + this._fileData[i].data.length - 1;\r\n\r\n      if (offset >= dataChunkStart && offset <= dataChunkEnd) {\r\n        dataChunk = this._fileData[i];\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (dataChunk) {\r\n      return dataChunk.data[offset - dataChunk.offset];\r\n    }\r\n\r\n    throw new Error(\"Offset \" + offset + \" hasn't been loaded yet.\");\r\n  }\r\n}\r\n\r\nexport default ChunkedFileData;\r\n","\r\n\r\n\r\nexport type DecodedString = InternalDecodedString;\r\n\r\nclass InternalDecodedString {\r\n  _value: string;\r\n  bytesReadCount: number;\r\n  length: number;\r\n\r\n  constructor(value: string, bytesReadCount: number) {\r\n    this._value = value;\r\n    this.bytesReadCount = bytesReadCount;\r\n    this.length = value.length;\r\n  }\r\n\r\n  toString(): string {\r\n    return this._value;\r\n  }\r\n}\r\n\r\nvar StringUtils = {\r\n  readUTF16String: function(\r\n    bytes: Array<number>,\r\n    bigEndian: boolean,\r\n    maxBytes?: number\r\n  ): DecodedString {\r\n    var ix = 0;\r\n    var offset1 = 1, offset2 = 0;\r\n\r\n    maxBytes = Math.min(maxBytes||bytes.length, bytes.length);\r\n\r\n    if( bytes[0] == 0xFE && bytes[1] == 0xFF ) {\r\n      bigEndian = true;\r\n      ix = 2;\r\n    } else if( bytes[0] == 0xFF && bytes[1] == 0xFE ) {\r\n      bigEndian = false;\r\n      ix = 2;\r\n    }\r\n    if( bigEndian ) {\r\n      offset1 = 0;\r\n      offset2 = 1;\r\n    }\r\n\r\n    var arr = [];\r\n    for( var j = 0; ix < maxBytes; j++ ) {\r\n        var byte1 = bytes[ix+offset1];\r\n        var byte2 = bytes[ix+offset2];\r\n        var word1 = (byte1<<8)+byte2;\r\n        ix += 2;\r\n        if( word1 == 0x0000 ) {\r\n            break;\r\n        } else if( byte1 < 0xD8 || byte1 >= 0xE0 ) {\r\n            arr[j] = String.fromCharCode(word1);\r\n        } else {\r\n            var byte3 = bytes[ix+offset1];\r\n            var byte4 = bytes[ix+offset2];\r\n            var word2 = (byte3<<8)+byte4;\r\n            ix += 2;\r\n            arr[j] = String.fromCharCode(word1, word2);\r\n        }\r\n    }\r\n    return new InternalDecodedString(arr.join(\"\"), ix);\r\n  },\r\n\r\n  readUTF8String: function(\r\n    bytes: Array<number>,\r\n    maxBytes?: number\r\n  ): DecodedString {\r\n    var ix = 0;\r\n    maxBytes = Math.min(maxBytes||bytes.length, bytes.length);\r\n\r\n    if( bytes[0] == 0xEF && bytes[1] == 0xBB && bytes[2] == 0xBF ) {\r\n      ix = 3;\r\n    }\r\n\r\n    var arr = [];\r\n    for( var j = 0; ix < maxBytes; j++ ) {\r\n      var byte1 = bytes[ix++];\r\n      if( byte1 == 0x00 ) {\r\n        break;\r\n      } else if( byte1 < 0x80 ) {\r\n        arr[j] = String.fromCharCode(byte1);\r\n      } else if( byte1 >= 0xC2 && byte1 < 0xE0 ) {\r\n        var byte2 = bytes[ix++];\r\n        arr[j] = String.fromCharCode(((byte1&0x1F)<<6) + (byte2&0x3F));\r\n      } else if( byte1 >= 0xE0 && byte1 < 0xF0 ) {\r\n        var byte2 = bytes[ix++];\r\n        var byte3 = bytes[ix++];\r\n        arr[j] = String.fromCharCode(((byte1&0xFF)<<12) + ((byte2&0x3F)<<6) + (byte3&0x3F));\r\n      } else if( byte1 >= 0xF0 && byte1 < 0xF5) {\r\n        var byte2 = bytes[ix++];\r\n        var byte3 = bytes[ix++];\r\n        var byte4 = bytes[ix++];\r\n        var codepoint = ((byte1&0x07)<<18) + ((byte2&0x3F)<<12)+ ((byte3&0x3F)<<6) + (byte4&0x3F) - 0x10000;\r\n        arr[j] = String.fromCharCode(\r\n          (codepoint>>10) + 0xD800,\r\n          (codepoint&0x3FF) + 0xDC00\r\n        );\r\n      }\r\n    }\r\n    return new InternalDecodedString(arr.join(\"\"), ix);\r\n  },\r\n\r\n  readNullTerminatedString: function(\r\n    bytes: Array<number>,\r\n    maxBytes?: number\r\n  ): DecodedString {\r\n    var arr = [];\r\n    maxBytes = maxBytes || bytes.length;\r\n    for ( var i = 0; i < maxBytes; ) {\r\n      var byte1 = bytes[i++];\r\n      if ( byte1 == 0x00 ) {\r\n        break;\r\n      }\r\n      arr[i-1] = String.fromCharCode(byte1);\r\n    }\r\n    return new InternalDecodedString(arr.join(\"\"), i);\r\n  }\r\n};\r\n\r\nexport default StringUtils;\r\n","import StringUtils from './StringUtils';\r\n\r\nimport type {\r\n  DecodedString\r\n} from './StringUtils';\r\n\r\nimport type {\r\n  LoadCallbackType,\r\n  CharsetType\r\n} from './FlowTypes';\r\n\r\nclass MediaFileReader {\r\n  _isInitialized: boolean;\r\n  _size: number;\r\n\r\n  constructor() {\r\n    this._isInitialized = false;\r\n    this._size = 0;\r\n  }\r\n\r\n  /**\r\n   * Decides if this media file reader is able to read the given file.\r\n   */\r\n  static canReadFile(file: any): boolean {\r\n    throw new Error(\"Must implement canReadFile function\");\r\n  }\r\n\r\n  /**\r\n   * This function needs to be called before any other function.\r\n   * Loads the necessary initial information from the file.\r\n   */\r\n  init(callbacks: LoadCallbackType): void {\r\n    var self = this;\r\n\r\n    if (this._isInitialized) {\r\n      setTimeout(callbacks.onSuccess, 1);\r\n    } else {\r\n      return this._init({\r\n        onSuccess: function() {\r\n          self._isInitialized = true;\r\n          callbacks.onSuccess();\r\n        },\r\n        onError: callbacks.onError\r\n      });\r\n    }\r\n  }\r\n\r\n  _init(callbacks: LoadCallbackType): void {\r\n    throw new Error(\"Must implement init function\");\r\n  }\r\n\r\n  /**\r\n   * @param range The start and end indexes of the range to load.\r\n   *        Ex: [0, 7] load bytes 0 to 7 inclusive.\r\n   */\r\n  loadRange(range: [number, number], callbacks: LoadCallbackType): void {\r\n    throw new Error(\"Must implement loadRange function\");\r\n  }\r\n\r\n  /**\r\n   * @return The size of the file in bytes.\r\n   */\r\n  getSize(): number {\r\n    if (!this._isInitialized) {\r\n      throw new Error(\"init() must be called first.\");\r\n    }\r\n\r\n    return this._size;\r\n  }\r\n\r\n  getByteAt(offset: number): number {\r\n    throw new Error(\"Must implement getByteAt function\");\r\n  }\r\n\r\n  getBytesAt(offset: number, length: number): Array<number> {\r\n    var bytes = new Array(length);\r\n    for( var i = 0; i < length; i++ ) {\r\n      bytes[i] = this.getByteAt(offset+i);\r\n    }\r\n    return bytes;\r\n  }\r\n\r\n  isBitSetAt(offset: number, bit: number): boolean {\r\n    var iByte = this.getByteAt(offset);\r\n    return (iByte & (1 << bit)) != 0;\r\n  }\r\n\r\n  getSByteAt(offset: number): number {\r\n    var iByte = this.getByteAt(offset);\r\n    if (iByte > 127) {\r\n      return iByte - 256;\r\n    } else {\r\n      return iByte;\r\n    }\r\n  }\r\n\r\n  getShortAt(offset: number, isBigEndian: boolean): number {\r\n    var iShort = isBigEndian\r\n      ? (this.getByteAt(offset) << 8) + this.getByteAt(offset + 1)\r\n      : (this.getByteAt(offset + 1) << 8) + this.getByteAt(offset);\r\n    if (iShort < 0) {\r\n      iShort += 65536;\r\n    }\r\n    return iShort;\r\n  }\r\n\r\n  getSShortAt(offset: number, isBigEndian: boolean): number {\r\n    var iUShort = this.getShortAt(offset, isBigEndian);\r\n    if (iUShort > 32767) {\r\n      return iUShort - 65536;\r\n    } else {\r\n      return iUShort;\r\n    }\r\n  }\r\n\r\n  getLongAt(offset: number, isBigEndian: boolean): number {\r\n    var iByte1 = this.getByteAt(offset),\r\n      iByte2 = this.getByteAt(offset + 1),\r\n      iByte3 = this.getByteAt(offset + 2),\r\n      iByte4 = this.getByteAt(offset + 3);\r\n\r\n    var iLong = isBigEndian\r\n      ? (((((iByte1 << 8) + iByte2) << 8) + iByte3) << 8) + iByte4\r\n      : (((((iByte4 << 8) + iByte3) << 8) + iByte2) << 8) + iByte1;\r\n\r\n    if (iLong < 0) {\r\n      iLong += 4294967296;\r\n    }\r\n\r\n    return iLong;\r\n  }\r\n\r\n  getSLongAt(offset: number, isBigEndian: boolean): number {\r\n    var iULong = this.getLongAt(offset, isBigEndian);\r\n\r\n    if (iULong > 2147483647) {\r\n      return iULong - 4294967296;\r\n    } else {\r\n      return iULong;\r\n    }\r\n  }\r\n\r\n  getInteger24At(offset: number, isBigEndian: boolean): number {\r\n    var iByte1 = this.getByteAt(offset),\r\n      iByte2 = this.getByteAt(offset + 1),\r\n      iByte3 = this.getByteAt(offset + 2);\r\n\r\n    var iInteger = isBigEndian\r\n      ? ((((iByte1 << 8) + iByte2) << 8) + iByte3)\r\n      : ((((iByte3 << 8) + iByte2) << 8) + iByte1);\r\n\r\n    if (iInteger < 0) {\r\n      iInteger += 16777216;\r\n    }\r\n\r\n    return iInteger;\r\n  }\r\n\r\n  getStringAt(offset: number, length: number): string {\r\n    var string = [];\r\n    for (var i = offset, j = 0; i < offset+length; i++, j++) {\r\n      string[j] = String.fromCharCode(this.getByteAt(i));\r\n    }\r\n    return string.join(\"\");\r\n  }\r\n\r\n  getStringWithCharsetAt(\r\n    offset: number,\r\n    length: number,\r\n    charset?: CharsetType\r\n  ): DecodedString {\r\n    var bytes = this.getBytesAt(offset, length);\r\n    var string;\r\n\r\n    switch ((charset||'').toLowerCase()) {\r\n      case \"utf-16\":\r\n      case \"utf-16le\":\r\n      case \"utf-16be\":\r\n        string = StringUtils.readUTF16String(bytes, charset === \"utf-16be\");\r\n        break;\r\n\r\n      case \"utf-8\":\r\n        string = StringUtils.readUTF8String(bytes);\r\n        break;\r\n\r\n      default:\r\n        string = StringUtils.readNullTerminatedString(bytes);\r\n        break;\r\n    }\r\n\r\n    return string;\r\n  }\r\n\r\n  getCharAt(offset: number): string {\r\n    return String.fromCharCode(this.getByteAt(offset));\r\n  }\r\n\r\n  /**\r\n   * The ID3v2 tag/frame size is encoded with four bytes where the most\r\n   * significant bit (bit 7) is set to zero in every byte, making a total of 28\r\n   * bits. The zeroed bits are ignored, so a 257 bytes long tag is represented\r\n   * as $00 00 02 01.\r\n   */\r\n  getSynchsafeInteger32At(offset: number): number {\r\n    var size1 = this.getByteAt(offset);\r\n    var size2 = this.getByteAt(offset+1);\r\n    var size3 = this.getByteAt(offset+2);\r\n    var size4 = this.getByteAt(offset+3);\r\n    // 0x7f = 0b01111111\r\n    var size =size4 & 0x7f\r\n      | ((size3 & 0x7f) << 7)\r\n      | ((size2 & 0x7f) << 14)\r\n      | ((size1 & 0x7f) << 21);\r\n\r\n    return size;\r\n  }\r\n}\r\n\r\nexport default MediaFileReader;\r\n","import ChunkedFileData from './ChunkedFileData';\r\nimport MediaFileReader from './MediaFileReader';\r\n\r\nconst CHUNK_SIZE = 1024;\r\n\r\nimport type {\r\n  LoadCallbackType,\r\n  CallbackType\r\n} from './FlowTypes';\r\n\r\ntype ContentRangeType = {\r\n  firstBytePosition?: number,\r\n  lastBytePosition?: number,\r\n  instanceLength?:number,\r\n};\r\n\r\nclass XhrFileReader extends MediaFileReader {\r\n  static _config: {\r\n    avoidHeadRequests: boolean,\r\n    disallowedXhrHeaders: Array<string>,\r\n    timeoutInSec: number\r\n  };\r\n  _url: string;\r\n  _fileData: ChunkedFileData;\r\n\r\n  constructor(url: string) {\r\n    super();\r\n    this._url = url;\r\n    this._fileData = new ChunkedFileData();\r\n  }\r\n\r\n  static canReadFile(file: any): boolean {\r\n    return (\r\n      typeof file === 'string' &&\r\n      /^[a-z]+:\\/\\//i.test(file)\r\n    );\r\n  }\r\n\r\n  static setConfig(config: Object) {\r\n    for (var key in config) if (config.hasOwnProperty(key)) {\r\n      this._config[key] = config[key];\r\n    }\r\n\r\n    var disallowedXhrHeaders = this._config.disallowedXhrHeaders;\r\n    for (var i = 0; i < disallowedXhrHeaders.length; i++) {\r\n      disallowedXhrHeaders[i] = disallowedXhrHeaders[i].toLowerCase();\r\n    }\r\n  }\r\n\r\n  _init(callbacks: LoadCallbackType): void {\r\n    if (XhrFileReader._config.avoidHeadRequests) {\r\n      this._fetchSizeWithGetRequest(callbacks);\r\n    } else {\r\n      this._fetchSizeWithHeadRequest(callbacks);\r\n    }\r\n  }\r\n\r\n  _fetchSizeWithHeadRequest(callbacks: LoadCallbackType): void {\r\n    var self = this;\r\n\r\n    this._makeXHRRequest(\"HEAD\", null, {\r\n      onSuccess: function(xhr: XMLHttpRequest) {\r\n        var contentLength = self._parseContentLength(xhr);\r\n        if (contentLength) {\r\n          self._size = contentLength;\r\n          callbacks.onSuccess();\r\n        } else {\r\n          // Content-Length not provided by the server, fallback to\r\n          // GET requests.\r\n          self._fetchSizeWithGetRequest(callbacks);\r\n        }\r\n      },\r\n      onError: callbacks.onError\r\n    });\r\n  }\r\n\r\n  _fetchSizeWithGetRequest(callbacks: LoadCallbackType): void {\r\n    var self = this;\r\n    var range = this._roundRangeToChunkMultiple([0, 0]);\r\n\r\n    this._makeXHRRequest(\"GET\", range, {\r\n      onSuccess: function(xhr: XMLHttpRequest) {\r\n        var contentRange = self._parseContentRange(xhr);\r\n        var data = self._getXhrResponseContent(xhr);\r\n\r\n        if (contentRange) {\r\n          if (contentRange.instanceLength == null) {\r\n            // Last resort, server is not able to tell us the content length,\r\n            // need to fetch entire file then.\r\n            self._fetchEntireFile(callbacks);\r\n            return;\r\n          }\r\n          self._size = contentRange.instanceLength;\r\n        } else {\r\n          // Range request not supported, we got the entire file\r\n          self._size = data.length;\r\n        }\r\n\r\n        self._fileData.addData(0, data);\r\n        callbacks.onSuccess();\r\n      },\r\n      onError: callbacks.onError\r\n    });\r\n  }\r\n\r\n  _fetchEntireFile(callbacks: LoadCallbackType): void {\r\n    var self = this;\r\n    this._makeXHRRequest(\"GET\", null, {\r\n      onSuccess: function(xhr: XMLHttpRequest) {\r\n        var data = self._getXhrResponseContent(xhr);\r\n        self._size = data.length;\r\n        self._fileData.addData(0, data);\r\n        callbacks.onSuccess();\r\n      },\r\n      onError: callbacks.onError\r\n    });\r\n  }\r\n\r\n  _getXhrResponseContent(xhr: XMLHttpRequest): string {\r\n    return xhr.response || xhr.responseText || \"\";\r\n  }\r\n\r\n  _parseContentLength(xhr: XMLHttpRequest): number | null {\r\n    var contentLength = this._getResponseHeader(xhr, \"Content-Length\");\r\n\r\n    if (contentLength == null) {\r\n      return contentLength;\r\n    } else {\r\n      return parseInt(contentLength, 10);\r\n    }\r\n  }\r\n\r\n  _parseContentRange(xhr: XMLHttpRequest): ContentRangeType | null {\r\n    var contentRange = this._getResponseHeader(xhr, \"Content-Range\");\r\n\r\n    if (contentRange) {\r\n      var parsedContentRange = contentRange.match(\r\n        /bytes (\\d+)-(\\d+)\\/(?:(\\d+)|\\*)/i\r\n      );\r\n      if (!parsedContentRange) {\r\n        throw new Error(\"FIXME: Unknown Content-Range syntax: \" + contentRange);\r\n      }\r\n\r\n      return {\r\n        firstBytePosition: parseInt(parsedContentRange[1], 10),\r\n        lastBytePosition: parseInt(parsedContentRange[2], 10),\r\n        instanceLength: parsedContentRange[3] ? parseInt(parsedContentRange[3], 10) : null\r\n      };\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n\r\n  loadRange(range: [number, number], callbacks: LoadCallbackType): void {\r\n    var self = this;\r\n\r\n    if (self._fileData.hasDataRange(range[0], Math.min(self._size, range[1]))) {\r\n      setTimeout(callbacks.onSuccess, 1);\r\n      return;\r\n    }\r\n\r\n    // Always download in multiples of CHUNK_SIZE. If we're going to make a\r\n    // request might as well get a chunk that makes sense. The big cost is\r\n    // establishing the connection so getting 10bytes or 1K doesn't really\r\n    // make a difference.\r\n    range = this._roundRangeToChunkMultiple(range);\r\n\r\n    // Upper range should not be greater than max file size\r\n    range[1] = Math.min(self._size, range[1]);\r\n\r\n    this._makeXHRRequest(\"GET\", range, {\r\n      onSuccess: function(xhr: XMLHttpRequest) {\r\n        var data = self._getXhrResponseContent(xhr);\r\n        self._fileData.addData(range[0], data);\r\n        callbacks.onSuccess();\r\n      },\r\n      onError: callbacks.onError\r\n    });\r\n  }\r\n\r\n  _roundRangeToChunkMultiple(range: [number, number]): [number, number] {\r\n    var length = range[1] - range[0] + 1;\r\n    var newLength = Math.ceil(length/CHUNK_SIZE) * CHUNK_SIZE;\r\n    return [range[0], range[0] + newLength - 1];\r\n  }\r\n\r\n  _makeXHRRequest(\r\n    method: string,\r\n    range: [number, number],\r\n    callbacks: CallbackType\r\n  ) {\r\n    var xhr = this._createXHRObject();\r\n    xhr.open(method, this._url);\r\n\r\n    var onXHRLoad = function() {\r\n      // 200 - OK\r\n      // 206 - Partial Content\r\n      // $FlowIssue - xhr will not be null here\r\n      if (xhr.status === 200 || xhr.status === 206) {\r\n        callbacks.onSuccess(xhr);\r\n      } else if (callbacks.onError) {\r\n        callbacks.onError({\r\n          \"type\": \"xhr\",\r\n          \"info\": \"Unexpected HTTP status \" + xhr.status + \".\",\r\n          \"xhr\": xhr\r\n        });\r\n      }\r\n      xhr = null;\r\n    };\r\n\r\n    if (typeof xhr.onload !== 'undefined') {\r\n      xhr.onload = onXHRLoad;\r\n      xhr.onerror = function() {\r\n        if (callbacks.onError) {\r\n          callbacks.onError({\r\n            \"type\": \"xhr\",\r\n            \"info\": \"Generic XHR error, check xhr object.\",\r\n            \"xhr\": xhr,\r\n          });\r\n        }\r\n      }\r\n    } else {\r\n      xhr.onreadystatechange = function() {\r\n        // $FlowIssue - xhr will not be null here\r\n        if (xhr.readyState === 4) {\r\n          onXHRLoad();\r\n        }\r\n      };\r\n    }\r\n\r\n    if (XhrFileReader._config.timeoutInSec) {\r\n      xhr.timeout = XhrFileReader._config.timeoutInSec * 1000;\r\n      xhr.ontimeout = function() {\r\n        if (callbacks.onError) {\r\n          callbacks.onError({\r\n            \"type\": \"xhr\",\r\n            // $FlowIssue - xhr.timeout will not be null\r\n            \"info\": \"Timeout after \" + (xhr.timeout/1000) + \"s. Use jsmediatags.Config.setXhrTimeout to override.\",\r\n            \"xhr\": xhr,\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    xhr.overrideMimeType(\"text/plain; charset=x-user-defined\");\r\n    if (range) {\r\n      this._setRequestHeader(xhr, \"Range\", \"bytes=\" + range[0] + \"-\" + range[1]);\r\n    }\r\n    this._setRequestHeader(xhr, \"If-Modified-Since\", \"Sat, 01 Jan 1970 00:00:00 GMT\");\r\n    xhr.send(null);\r\n  }\r\n\r\n  _setRequestHeader(xhr: XMLHttpRequest, headerName: string, headerValue: string) {\r\n    if (XhrFileReader._config.disallowedXhrHeaders.indexOf(headerName.toLowerCase()) < 0) {\r\n      xhr.setRequestHeader(headerName, headerValue);\r\n    }\r\n  }\r\n\r\n  _hasResponseHeader(xhr: XMLHttpRequest, headerName: string): boolean {\r\n    var allResponseHeaders = xhr.getAllResponseHeaders();\r\n\r\n    if (!allResponseHeaders) {\r\n      return false;\r\n    }\r\n\r\n    var headers = allResponseHeaders.split(\"\\r\\n\");\r\n    var headerNames = [];\r\n    for (var i = 0; i < headers.length; i++) {\r\n      headerNames[i] = headers[i].split(\":\")[0].toLowerCase();\r\n    }\r\n\r\n    return headerNames.indexOf(headerName.toLowerCase()) >= 0;\r\n  }\r\n\r\n  _getResponseHeader(xhr: XMLHttpRequest, headerName: string): string | null {\r\n    if (!this._hasResponseHeader(xhr, headerName)) {\r\n      return null;\r\n    }\r\n\r\n    return xhr.getResponseHeader(headerName);\r\n  }\r\n\r\n  getByteAt(offset: number): number {\r\n    var character = this._fileData.getByteAt(offset);\r\n    return character.charCodeAt(0) & 0xff;\r\n  }\r\n\r\n  _createXHRObject(): XMLHttpRequest {\r\n\r\n\r\n    if (typeof XMLHttpRequest !== \"undefined\") {\r\n      return new XMLHttpRequest();\r\n    }\r\n\r\n    throw new Error(\"XMLHttpRequest is not supported\");\r\n  }\r\n}\r\n\r\nXhrFileReader._config = {\r\n  avoidHeadRequests: false,\r\n  disallowedXhrHeaders: [],\r\n  timeoutInSec: 30\r\n};\r\n\r\nexport default XhrFileReader;\r\n","import ChunkedFileData from \"./ChunkedFileData\";\r\nimport MediaFileReader from \"./MediaFileReader\";\r\n\r\nimport type { LoadCallbackType } from \"./FlowTypes\";\r\n\r\nclass BlobFileReader extends MediaFileReader {\r\n  _blob: Blob;\r\n  _fileData: ChunkedFileData;\r\n\r\n  constructor(blob: Blob) {\r\n    super();\r\n    this._blob = blob;\r\n    this._fileData = new ChunkedFileData();\r\n  }\r\n\r\n  static canReadFile(file: any): boolean {\r\n    return (\r\n      (typeof Blob !== \"undefined\" && file instanceof Blob) ||\r\n      // File extends Blob but it seems that File instanceof Blob doesn't\r\n      // quite work as expected in Cordova/PhoneGap.\r\n      (typeof File !== \"undefined\" && file instanceof File)\r\n    );\r\n  }\r\n\r\n  _init(callbacks: LoadCallbackType): void {\r\n    this._size = this._blob.size;\r\n    setTimeout(callbacks.onSuccess, 1);\r\n  }\r\n\r\n  loadRange(range: [number, number], callbacks: LoadCallbackType): void {\r\n    var self = this;\r\n    // $FlowIssue - flow isn't aware of mozSlice or webkitSlice\r\n    var blobSlice = this._blob.slice\r\n    var blob = blobSlice.call(this._blob, range[0], range[1] + 1);\r\n    var browserFileReader = new FileReader();\r\n\r\n    browserFileReader.onloadend = function (event) {\r\n      var intArray = new Uint8Array(browserFileReader.result);\r\n      self._fileData.addData(range[0], intArray);\r\n      callbacks.onSuccess();\r\n    };\r\n    browserFileReader.onerror = browserFileReader.onabort = function (event) {\r\n      if (callbacks.onError) {\r\n        callbacks.onError({ type: \"blob\", info: browserFileReader.error });\r\n      }\r\n    };\r\n\r\n    browserFileReader.readAsArrayBuffer(blob);\r\n  }\r\n\r\n  getByteAt(offset: number): number {\r\n    return this._fileData.getByteAt(offset);\r\n  }\r\n}\r\n\r\nexport default BlobFileReader;\r\n","import MediaFileReader from \"./MediaFileReader\";\r\n\r\nimport type { Byte, ByteArray, LoadCallbackType } from \"./FlowTypes\";\r\n\r\nclass ArrayFileReader extends MediaFileReader {\r\n  _array: ByteArray;\r\n  _size: number;\r\n\r\n  constructor(array: ByteArray) {\r\n    super();\r\n    this._array = array;\r\n    this._size = array.length;\r\n    this._isInitialized = true;\r\n  }\r\n\r\n  static canReadFile(file: any): boolean {\r\n    return (\r\n      Array.isArray(file) ||\r\n      (typeof Buffer === \"function\" && Buffer.isBuffer(file))\r\n    );\r\n  }\r\n\r\n  init(callbacks: LoadCallbackType) {\r\n    setTimeout(callbacks.onSuccess, 0);\r\n  }\r\n\r\n  loadRange(range: [number, number], callbacks: LoadCallbackType) {\r\n    setTimeout(callbacks.onSuccess, 0);\r\n  }\r\n\r\n  getByteAt(offset: number): Byte {\r\n    if (offset >= this._array.length) {\r\n      throw new Error(\"Offset \" + offset + \" hasn't been loaded yet.\");\r\n    }\r\n    return this._array[offset];\r\n  }\r\n}\r\n\r\nexport default ArrayFileReader;\r\n","import MediaFileReader from \"./MediaFileReader\";\r\n\r\nimport type {\r\n  CallbackType,\r\n  LoadCallbackType,\r\n  ByteRange,\r\n  TagType,\r\n} from \"./FlowTypes\";\r\n\r\nclass MediaTagReader {\r\n  _mediaFileReader: MediaFileReader;\r\n  _tags?: Array<string> | null;\r\n\r\n  constructor(mediaFileReader: MediaFileReader) {\r\n    this._mediaFileReader = mediaFileReader;\r\n    this._tags = null;\r\n  }\r\n\r\n  /**\r\n   * Returns the byte range that needs to be loaded and fed to\r\n   * _canReadTagFormat in order to identify if the file contains tag\r\n   * information that can be read.\r\n   */\r\n  static getTagIdentifierByteRange(): ByteRange {\r\n    throw new Error(\"Must implement\");\r\n  }\r\n\r\n  /**\r\n   * Given a tag identifier (read from the file byte positions speficied by\r\n   * getTagIdentifierByteRange) this function checks if it can read the tag\r\n   * format or not.\r\n   */\r\n  static canReadTagFormat(tagIdentifier: Array<number>): boolean {\r\n    throw new Error(\"Must implement\");\r\n  }\r\n\r\n  setTagsToRead(tags: Array<string>): MediaTagReader {\r\n    this._tags = tags;\r\n    return this;\r\n  }\r\n\r\n  read(callbacks: CallbackType) {\r\n    var self = this;\r\n\r\n    this._mediaFileReader.init({\r\n      onSuccess: function () {\r\n        self._loadData(self._mediaFileReader, {\r\n          onSuccess: function () {\r\n            try {\r\n              var tags = self._parseData(self._mediaFileReader, self._tags);\r\n            } catch (ex) {\r\n              if (callbacks.onError) {\r\n                callbacks.onError({\r\n                  type: \"parseData\",\r\n                  info: ex.message,\r\n                });\r\n                return;\r\n              }\r\n            }\r\n\r\n            // TODO: destroy mediaFileReader\r\n            callbacks.onSuccess(tags);\r\n          },\r\n          onError: callbacks.onError,\r\n        });\r\n      },\r\n      onError: callbacks.onError,\r\n    });\r\n  }\r\n\r\n  getShortcuts(): { [key: string]: string | Array<string> } {\r\n    return {};\r\n  }\r\n\r\n  /**\r\n   * Load the necessary bytes from the media file.\r\n   */\r\n  _loadData(\r\n    mediaFileReader: MediaFileReader,\r\n    callbacks: LoadCallbackType\r\n  ): void {\r\n    throw new Error(\"Must implement _loadData function\");\r\n  }\r\n\r\n  /**\r\n   * Parse the loaded data to read the media tags.\r\n   */\r\n  _parseData(mediaFileReader: MediaFileReader, tags: Array<string>): TagType {\r\n    throw new Error(\"Must implement _parseData function\");\r\n  }\r\n\r\n  _expandShortcutTags(tagsWithShortcuts: Array<string>): Array<string> | null {\r\n    if (!tagsWithShortcuts) {\r\n      return null;\r\n    }\r\n\r\n    var tags = [];\r\n    var shortcuts = this.getShortcuts();\r\n    for (\r\n      var i = 0, tagOrShortcut;\r\n      (tagOrShortcut = tagsWithShortcuts[i]);\r\n      i++\r\n    ) {\r\n      tags = tags.concat(shortcuts[tagOrShortcut] || [tagOrShortcut]);\r\n    }\r\n\r\n    return tags;\r\n  }\r\n}\r\n\r\nexport default MediaTagReader;\r\n","\r\n\r\n\r\nimport MediaFileReader from './MediaFileReader';\r\n\r\nimport type {\r\n  LoadCallbackType,\r\n  ByteRange,\r\n  TagType\r\n} from './FlowTypes';\r\nimport MediaTagReader from './MediaTagReader';\r\n\r\nclass ID3v1TagReader extends MediaTagReader {\r\n  static getTagIdentifierByteRange(): ByteRange {\r\n    // The identifier is TAG and is at offset: -128. However, to avoid a\r\n    // fetch for the tag identifier and another for the data, we load the\r\n    // entire data since it's so small.\r\n    return {\r\n      offset: -128,\r\n      length: 128\r\n    };\r\n  }\r\n\r\n  static canReadTagFormat(tagIdentifier: Array<number>): boolean {\r\n    var id = String.fromCharCode.apply(String, tagIdentifier.slice(0, 3));\r\n    return id === \"TAG\";\r\n  }\r\n\r\n  _loadData(mediaFileReader: MediaFileReader, callbacks: LoadCallbackType) {\r\n    var fileSize = mediaFileReader.getSize();\r\n    mediaFileReader.loadRange([fileSize - 128, fileSize - 1], callbacks);\r\n  }\r\n\r\n  _parseData(data: MediaFileReader, tags: Array<string>): TagType {\r\n    var offset = data.getSize() - 128;\r\n\r\n    var title = data.getStringWithCharsetAt(offset + 3, 30).toString();\r\n    var artist = data.getStringWithCharsetAt(offset + 33, 30).toString();\r\n    var album = data.getStringWithCharsetAt(offset + 63, 30).toString();\r\n    var year = data.getStringWithCharsetAt(offset + 93, 4).toString();\r\n\r\n    var trackFlag = data.getByteAt(offset + 97 + 28);\r\n    var track = data.getByteAt(offset + 97 + 29);\r\n    if (trackFlag == 0 && track != 0) {\r\n      var version = \"1.1\";\r\n      var comment = data.getStringWithCharsetAt(offset + 97, 28).toString();\r\n    } else {\r\n      var version = \"1.0\";\r\n      var comment = data.getStringWithCharsetAt(offset + 97, 30).toString();\r\n      track = 0;\r\n    }\r\n\r\n    var genreIdx = data.getByteAt(offset + 97 + 30);\r\n    if (genreIdx < 255) {\r\n      var genre = GENRES[genreIdx];\r\n    } else {\r\n      var genre = \"\";\r\n    }\r\n\r\n    var tag = {\r\n      \"type\": \"ID3\",\r\n      \"version\" : version,\r\n      \"tags\": {\r\n        \"title\" : title,\r\n        \"artist\" : artist,\r\n        \"album\" : album,\r\n        \"year\" : year,\r\n        \"comment\" : comment,\r\n        \"genre\" : genre\r\n      }\r\n    };\r\n\r\n    if (track) {\r\n      // $FlowIssue - flow is not happy with adding properties\r\n      tag.tags.track = track;\r\n    }\r\n\r\n    return tag;\r\n  }\r\n}\r\n\r\nvar GENRES = [\r\n  \"Blues\",\"Classic Rock\",\"Country\",\"Dance\",\"Disco\",\"Funk\",\"Grunge\",\r\n  \"Hip-Hop\",\"Jazz\",\"Metal\",\"New Age\",\"Oldies\",\"Other\",\"Pop\",\"R&B\",\r\n  \"Rap\",\"Reggae\",\"Rock\",\"Techno\",\"Industrial\",\"Alternative\",\"Ska\",\r\n  \"Death Metal\",\"Pranks\",\"Soundtrack\",\"Euro-Techno\",\"Ambient\",\r\n  \"Trip-Hop\",\"Vocal\",\"Jazz+Funk\",\"Fusion\",\"Trance\",\"Classical\",\r\n  \"Instrumental\",\"Acid\",\"House\",\"Game\",\"Sound Clip\",\"Gospel\",\r\n  \"Noise\",\"AlternRock\",\"Bass\",\"Soul\",\"Punk\",\"Space\",\"Meditative\",\r\n  \"Instrumental Pop\",\"Instrumental Rock\",\"Ethnic\",\"Gothic\",\r\n  \"Darkwave\",\"Techno-Industrial\",\"Electronic\",\"Pop-Folk\",\r\n  \"Eurodance\",\"Dream\",\"Southern Rock\",\"Comedy\",\"Cult\",\"Gangsta\",\r\n  \"Top 40\",\"Christian Rap\",\"Pop/Funk\",\"Jungle\",\"Native American\",\r\n  \"Cabaret\",\"New Wave\",\"Psychadelic\",\"Rave\",\"Showtunes\",\"Trailer\",\r\n  \"Lo-Fi\",\"Tribal\",\"Acid Punk\",\"Acid Jazz\",\"Polka\",\"Retro\",\r\n  \"Musical\",\"Rock & Roll\",\"Hard Rock\",\"Folk\",\"Folk-Rock\",\r\n  \"National Folk\",\"Swing\",\"Fast Fusion\",\"Bebob\",\"Latin\",\"Revival\",\r\n  \"Celtic\",\"Bluegrass\",\"Avantgarde\",\"Gothic Rock\",\"Progressive Rock\",\r\n  \"Psychedelic Rock\",\"Symphonic Rock\",\"Slow Rock\",\"Big Band\",\r\n  \"Chorus\",\"Easy Listening\",\"Acoustic\",\"Humour\",\"Speech\",\"Chanson\",\r\n  \"Opera\",\"Chamber Music\",\"Sonata\",\"Symphony\",\"Booty Bass\",\"Primus\",\r\n  \"Porn Groove\",\"Satire\",\"Slow Jam\",\"Club\",\"Tango\",\"Samba\",\r\n  \"Folklore\",\"Ballad\",\"Power Ballad\",\"Rhythmic Soul\",\"Freestyle\",\r\n  \"Duet\",\"Punk Rock\",\"Drum Solo\",\"Acapella\",\"Euro-House\",\"Dance Hall\"\r\n];\r\n\r\nexport default ID3v1TagReader;\r\n","\r\nimport StringUtils from './StringUtils';\r\n\r\nimport type {\r\n  CharsetType,\r\n  FrameReaderSignature,\r\n  TagHeader,\r\n  TagFrames,\r\n  TagFrameHeader,\r\n  TagFrameFlags\r\n} from './FlowTypes';\r\nimport ArrayFileReader from './ArrayFileReader';\r\nimport MediaFileReader from './MediaFileReader';\r\n\r\nconst  frameReaderFunctions:Record<string,any> = {};\r\n\r\nconst FRAME_DESCRIPTIONS = {\r\n  // v2.2\r\n  \"BUF\" : \"Recommended buffer size\",\r\n  \"CNT\" : \"Play counter\",\r\n  \"COM\" : \"Comments\",\r\n  \"CRA\" : \"Audio encryption\",\r\n  \"CRM\" : \"Encrypted meta frame\",\r\n  \"ETC\" : \"Event timing codes\",\r\n  \"EQU\" : \"Equalization\",\r\n  \"GEO\" : \"General encapsulated object\",\r\n  \"IPL\" : \"Involved people list\",\r\n  \"LNK\" : \"Linked information\",\r\n  \"MCI\" : \"Music CD Identifier\",\r\n  \"MLL\" : \"MPEG location lookup table\",\r\n  \"PIC\" : \"Attached picture\",\r\n  \"POP\" : \"Popularimeter\",\r\n  \"REV\" : \"Reverb\",\r\n  \"RVA\" : \"Relative volume adjustment\",\r\n  \"SLT\" : \"Synchronized lyric/text\",\r\n  \"STC\" : \"Synced tempo codes\",\r\n  \"TAL\" : \"Album/Movie/Show title\",\r\n  \"TBP\" : \"BPM (Beats Per Minute)\",\r\n  \"TCM\" : \"Composer\",\r\n  \"TCO\" : \"Content type\",\r\n  \"TCR\" : \"Copyright message\",\r\n  \"TDA\" : \"Date\",\r\n  \"TDY\" : \"Playlist delay\",\r\n  \"TEN\" : \"Encoded by\",\r\n  \"TFT\" : \"File type\",\r\n  \"TIM\" : \"Time\",\r\n  \"TKE\" : \"Initial key\",\r\n  \"TLA\" : \"Language(s)\",\r\n  \"TLE\" : \"Length\",\r\n  \"TMT\" : \"Media type\",\r\n  \"TOA\" : \"Original artist(s)/performer(s)\",\r\n  \"TOF\" : \"Original filename\",\r\n  \"TOL\" : \"Original Lyricist(s)/text writer(s)\",\r\n  \"TOR\" : \"Original release year\",\r\n  \"TOT\" : \"Original album/Movie/Show title\",\r\n  \"TP1\" : \"Lead artist(s)/Lead performer(s)/Soloist(s)/Performing group\",\r\n  \"TP2\" : \"Band/Orchestra/Accompaniment\",\r\n  \"TP3\" : \"Conductor/Performer refinement\",\r\n  \"TP4\" : \"Interpreted, remixed, or otherwise modified by\",\r\n  \"TPA\" : \"Part of a set\",\r\n  \"TPB\" : \"Publisher\",\r\n  \"TRC\" : \"ISRC (International Standard Recording Code)\",\r\n  \"TRD\" : \"Recording dates\",\r\n  \"TRK\" : \"Track number/Position in set\",\r\n  \"TSI\" : \"Size\",\r\n  \"TSS\" : \"Software/hardware and settings used for encoding\",\r\n  \"TT1\" : \"Content group description\",\r\n  \"TT2\" : \"Title/Songname/Content description\",\r\n  \"TT3\" : \"Subtitle/Description refinement\",\r\n  \"TXT\" : \"Lyricist/text writer\",\r\n  \"TXX\" : \"User defined text information frame\",\r\n  \"TYE\" : \"Year\",\r\n  \"UFI\" : \"Unique file identifier\",\r\n  \"ULT\" : \"Unsychronized lyric/text transcription\",\r\n  \"WAF\" : \"Official audio file webpage\",\r\n  \"WAR\" : \"Official artist/performer webpage\",\r\n  \"WAS\" : \"Official audio source webpage\",\r\n  \"WCM\" : \"Commercial information\",\r\n  \"WCP\" : \"Copyright/Legal information\",\r\n  \"WPB\" : \"Publishers official webpage\",\r\n  \"WXX\" : \"User defined URL link frame\",\r\n  // v2.3\r\n  \"AENC\" : \"Audio encryption\",\r\n  \"APIC\" : \"Attached picture\",\r\n  \"ASPI\" : \"Audio seek point index\",\r\n  \"CHAP\" : \"Chapter\",\r\n  \"CTOC\" : \"Table of contents\",\r\n  \"COMM\" : \"Comments\",\r\n  \"COMR\" : \"Commercial frame\",\r\n  \"ENCR\" : \"Encryption method registration\",\r\n  \"EQU2\" : \"Equalisation (2)\",\r\n  \"EQUA\" : \"Equalization\",\r\n  \"ETCO\" : \"Event timing codes\",\r\n  \"GEOB\" : \"General encapsulated object\",\r\n  \"GRID\" : \"Group identification registration\",\r\n  \"IPLS\" : \"Involved people list\",\r\n  \"LINK\" : \"Linked information\",\r\n  \"MCDI\" : \"Music CD identifier\",\r\n  \"MLLT\" : \"MPEG location lookup table\",\r\n  \"OWNE\" : \"Ownership frame\",\r\n  \"PRIV\" : \"Private frame\",\r\n  \"PCNT\" : \"Play counter\",\r\n  \"POPM\" : \"Popularimeter\",\r\n  \"POSS\" : \"Position synchronisation frame\",\r\n  \"RBUF\" : \"Recommended buffer size\",\r\n  \"RVA2\" : \"Relative volume adjustment (2)\",\r\n  \"RVAD\" : \"Relative volume adjustment\",\r\n  \"RVRB\" : \"Reverb\",\r\n  \"SEEK\" : \"Seek frame\",\r\n  \"SYLT\" : \"Synchronized lyric/text\",\r\n  \"SYTC\" : \"Synchronized tempo codes\",\r\n  \"TALB\" : \"Album/Movie/Show title\",\r\n  \"TBPM\" : \"BPM (beats per minute)\",\r\n  \"TCOM\" : \"Composer\",\r\n  \"TCON\" : \"Content type\",\r\n  \"TCOP\" : \"Copyright message\",\r\n  \"TDAT\" : \"Date\",\r\n  \"TDLY\" : \"Playlist delay\",\r\n  \"TDRC\" : \"Recording time\",\r\n  \"TDRL\" : \"Release time\",\r\n  \"TDTG\" : \"Tagging time\",\r\n  \"TENC\" : \"Encoded by\",\r\n  \"TEXT\" : \"Lyricist/Text writer\",\r\n  \"TFLT\" : \"File type\",\r\n  \"TIME\" : \"Time\",\r\n  \"TIPL\" : \"Involved people list\",\r\n  \"TIT1\" : \"Content group description\",\r\n  \"TIT2\" : \"Title/songname/content description\",\r\n  \"TIT3\" : \"Subtitle/Description refinement\",\r\n  \"TKEY\" : \"Initial key\",\r\n  \"TLAN\" : \"Language(s)\",\r\n  \"TLEN\" : \"Length\",\r\n  \"TMCL\" : \"Musician credits list\",\r\n  \"TMED\" : \"Media type\",\r\n  \"TMOO\" : \"Mood\",\r\n  \"TOAL\" : \"Original album/movie/show title\",\r\n  \"TOFN\" : \"Original filename\",\r\n  \"TOLY\" : \"Original lyricist(s)/text writer(s)\",\r\n  \"TOPE\" : \"Original artist(s)/performer(s)\",\r\n  \"TORY\" : \"Original release year\",\r\n  \"TOWN\" : \"File owner/licensee\",\r\n  \"TPE1\" : \"Lead performer(s)/Soloist(s)\",\r\n  \"TPE2\" : \"Band/orchestra/accompaniment\",\r\n  \"TPE3\" : \"Conductor/performer refinement\",\r\n  \"TPE4\" : \"Interpreted, remixed, or otherwise modified by\",\r\n  \"TPOS\" : \"Part of a set\",\r\n  \"TPRO\" : \"Produced notice\",\r\n  \"TPUB\" : \"Publisher\",\r\n  \"TRCK\" : \"Track number/Position in set\",\r\n  \"TRDA\" : \"Recording dates\",\r\n  \"TRSN\" : \"Internet radio station name\",\r\n  \"TRSO\" : \"Internet radio station owner\",\r\n  \"TSOA\" : \"Album sort order\",\r\n  \"TSOP\" : \"Performer sort order\",\r\n  \"TSOT\" : \"Title sort order\",\r\n  \"TSIZ\" : \"Size\",\r\n  \"TSRC\" : \"ISRC (international standard recording code)\",\r\n  \"TSSE\" : \"Software/Hardware and settings used for encoding\",\r\n  \"TSST\" : \"Set subtitle\",\r\n  \"TYER\" : \"Year\",\r\n  \"TXXX\" : \"User defined text information frame\",\r\n  \"UFID\" : \"Unique file identifier\",\r\n  \"USER\" : \"Terms of use\",\r\n  \"USLT\" : \"Unsychronized lyric/text transcription\",\r\n  \"WCOM\" : \"Commercial information\",\r\n  \"WCOP\" : \"Copyright/Legal information\",\r\n  \"WOAF\" : \"Official audio file webpage\",\r\n  \"WOAR\" : \"Official artist/performer webpage\",\r\n  \"WOAS\" : \"Official audio source webpage\",\r\n  \"WORS\" : \"Official internet radio station homepage\",\r\n  \"WPAY\" : \"Payment\",\r\n  \"WPUB\" : \"Publishers official webpage\",\r\n  \"WXXX\" : \"User defined URL link frame\"\r\n};\r\n\r\nclass ID3v2FrameReader {\r\n  static getFrameReaderFunction(frameId: string): FrameReaderSignature {\r\n    if (frameId in frameReaderFunctions) {\r\n      return frameReaderFunctions[frameId];\r\n    } else if (frameId[0] === \"T\") {\r\n      // All frame ids starting with T are text tags.\r\n      return frameReaderFunctions[\"T*\"];\r\n    } else if (frameId[0] === \"W\") {\r\n      // All frame ids starting with W are url tags.\r\n      return frameReaderFunctions[\"W*\"];\r\n    } else {\r\n      return null;\r\n    }\r\n  }\r\n  /**\r\n   * All the frames consists of a frame header followed by one or more fields\r\n   * containing the actual information.\r\n   * The frame ID made out of the characters capital A-Z and 0-9. Identifiers\r\n   * beginning with \"X\", \"Y\" and \"Z\" are for experimental use and free for\r\n   * everyone to use, without the need to set the experimental bit in the tag\r\n   * header. Have in mind that someone else might have used the same identifier\r\n   * as you. All other identifiers are either used or reserved for future use.\r\n   * The frame ID is followed by a size descriptor, making a total header size\r\n   * of ten bytes in every frame. The size is calculated as frame size excluding\r\n   * frame header (frame size - 10).\r\n   */\r\n  static readFrames(\r\n    offset: number,\r\n    end: number,\r\n    data: MediaFileReader,\r\n    id3header: TagHeader,\r\n    tags:Array<string>\r\n  ): TagFrames {\r\n    var frames = {};\r\n    var frameHeaderSize = this._getFrameHeaderSize(id3header);\r\n    // console.log('header', id3header);\r\n    while (\r\n      // we should be able to read at least the frame header\r\n      offset < (end - frameHeaderSize)\r\n    ) {\r\n      var header = this._readFrameHeader(data, offset, id3header);\r\n      var frameId = header.id;\r\n\r\n      // No frame ID sometimes means it's the last frame (GTFO).\r\n      if (!frameId) {\r\n        break;\r\n      }\r\n\r\n      var flags = header.flags;\r\n      var frameSize = header.size;\r\n      var frameDataOffset = offset + header.headerSize;\r\n      var frameData = data;\r\n\r\n      // console.log(offset, frameId, header.size + header.headerSize, flags && flags.format.unsynchronisation);\r\n      // advance data offset to the next frame data\r\n      offset += header.headerSize + header.size;\r\n\r\n      // skip unwanted tags\r\n      if (tags && tags.indexOf(frameId) === -1) {\r\n        continue;\r\n      }\r\n      // Workaround: MP3ext V3.3.17 places a non-compliant padding string at\r\n      // the end of the ID3v2 header. A string like \"MP3ext V3.3.19(ansi)\"\r\n      // is added multiple times at the end of the ID3 tag. More information\r\n      // about this issue can be found at\r\n      // https://github.com/aadsm/jsmediatags/issues/58#issuecomment-313865336\r\n      if (\r\n        frameId === 'MP3e' || frameId === '\\x00MP3' ||\r\n        frameId === '\\x00\\x00MP' || frameId === ' MP3'\r\n      ) {\r\n        break;\r\n      }\r\n\r\n      var unsyncData;\r\n      if (flags && flags.format.unsynchronisation && !id3header.flags.unsynchronisation) {\r\n        frameData = this.getUnsyncFileReader(frameData, frameDataOffset, frameSize);\r\n        frameDataOffset = 0;\r\n        frameSize = frameData.getSize();\r\n      }\r\n\r\n      // the first 4 bytes are the real data size\r\n      // (after unsynchronisation && encryption)\r\n      if (flags && flags.format.data_length_indicator) {\r\n        // var frameDataSize = frameData.getSynchsafeInteger32At(frameDataOffset);\r\n        frameDataOffset += 4;\r\n        frameSize -= 4;\r\n      }\r\n\r\n      var readFrameFunc = ID3v2FrameReader.getFrameReaderFunction(frameId);\r\n      var parsedData = readFrameFunc ? readFrameFunc.apply(this, [frameDataOffset, frameSize, frameData, flags, id3header]) : null;\r\n      var desc = this._getFrameDescription(frameId);\r\n\r\n      var frame = {\r\n        id: frameId,\r\n        size: frameSize,\r\n        description: desc,\r\n        data: parsedData\r\n      };\r\n\r\n      if( frameId in frames ) {\r\n        if( frames[frameId].id ) {\r\n          frames[frameId] = [frames[frameId]];\r\n        }\r\n        frames[frameId].push(frame);\r\n      } else {\r\n        frames[frameId] = frame;\r\n      }\r\n    }\r\n\r\n    return frames;\r\n  }\r\n\r\n  static _getFrameHeaderSize(id3header: TagHeader): number {\r\n    var major = id3header.major;\r\n\r\n    if (major == 2) {\r\n      return 6;\r\n    } else if (major == 3 || major == 4) {\r\n      return 10;\r\n    } else {\r\n      return 0;\r\n    }\r\n  }\r\n\r\n  static _readFrameHeader(\r\n    data: MediaFileReader,\r\n    offset: number,\r\n    id3header: TagHeader\r\n  ): TagFrameHeader {\r\n    var major = id3header.major;\r\n    var flags = null;\r\n    var frameHeaderSize = this._getFrameHeaderSize(id3header);\r\n\r\n    switch (major) {\r\n      case 2:\r\n      var frameId = data.getStringAt(offset, 3);\r\n      var frameSize = data.getInteger24At(offset+3, true);\r\n      break;\r\n\r\n      case 3:\r\n      var frameId = data.getStringAt(offset, 4);\r\n      var frameSize = data.getLongAt(offset+4, true);\r\n      break;\r\n\r\n      case 4:\r\n      var frameId = data.getStringAt(offset, 4);\r\n      var frameSize = data.getSynchsafeInteger32At(offset+4);\r\n      break;\r\n    }\r\n\r\n    if (\r\n      frameId == String.fromCharCode(0,0,0) ||\r\n      frameId == String.fromCharCode(0,0,0,0)\r\n    ) {\r\n      frameId = \"\";\r\n    }\r\n\r\n    // if frameId is empty then it's the last frame\r\n    if (frameId) {\r\n      // read frame message and format flags\r\n      if (major > 2) {\r\n        flags = this._readFrameFlags(data, offset+8);\r\n      }\r\n    }\r\n\r\n    return {\r\n      \"id\": frameId || \"\",\r\n      \"size\": frameSize || 0,\r\n      \"headerSize\": frameHeaderSize || 0,\r\n      \"flags\": flags\r\n    };\r\n  }\r\n\r\n  static _readFrameFlags(data: MediaFileReader, offset: number): TagFrameFlags {\r\n    return {\r\n      message: {\r\n        tag_alter_preservation  : data.isBitSetAt(offset, 6),\r\n        file_alter_preservation : data.isBitSetAt(offset, 5),\r\n        read_only               : data.isBitSetAt(offset, 4)\r\n      },\r\n      format: {\r\n        grouping_identity       : data.isBitSetAt(offset+1, 7),\r\n        compression             : data.isBitSetAt(offset+1, 3),\r\n        encryption              : data.isBitSetAt(offset+1, 2),\r\n        unsynchronisation       : data.isBitSetAt(offset+1, 1),\r\n        data_length_indicator   : data.isBitSetAt(offset+1, 0)\r\n      }\r\n    };\r\n  }\r\n\r\n  static _getFrameDescription(frameId: string): string {\r\n    if (frameId in FRAME_DESCRIPTIONS) {\r\n      return FRAME_DESCRIPTIONS[frameId];\r\n    } else {\r\n      return 'Unknown';\r\n    }\r\n  }\r\n\r\n  static getUnsyncFileReader(\r\n    data: MediaFileReader,\r\n    offset: number,\r\n    size: number\r\n  ): MediaFileReader {\r\n    var frameData = data.getBytesAt(offset, size);\r\n    for (var i = 0; i < frameData.length - 1; i++) {\r\n      if (frameData[i] === 0xff && frameData[i+1] === 0x00) {\r\n        frameData.splice(i+1, 1);\r\n      }\r\n    }\r\n\r\n    return new ArrayFileReader(frameData);\r\n  }\r\n};\r\n\r\nframeReaderFunctions['APIC'] = function readPictureFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags:Object,\r\n  id3header?: TagHeader\r\n): any {\r\n  var start = offset;\r\n  var charset = getTextEncoding(data.getByteAt(offset));\r\n  switch (id3header && id3header.major) {\r\n    case 2:\r\n    var format = data.getStringAt(offset+1, 3);\r\n    offset += 4;\r\n    break;\r\n\r\n    case 3:\r\n    case 4:\r\n    var format = data.getStringWithCharsetAt(offset+1, length - 1);\r\n    offset += 1 + format.bytesReadCount;\r\n    break;\r\n\r\n    default:\r\n    throw new Error(\"Couldn't read ID3v2 major version.\");\r\n  }\r\n  var bite = data.getByteAt(offset);\r\n  var type = PICTURE_TYPE[bite];\r\n  var desc = data.getStringWithCharsetAt(offset+1, length - (offset-start) - 1, charset);\r\n\r\n  offset += 1 + desc.bytesReadCount;\r\n\r\n  return {\r\n    \"format\" : format.toString(),\r\n    \"type\" : type,\r\n    \"description\" : desc.toString(),\r\n    \"data\" : data.getBytesAt(offset, (start+length) - offset)\r\n  };\r\n};\r\n\r\n// ID3v2 chapters according to http://id3.org/id3v2-chapters-1.0\r\nframeReaderFunctions['CHAP'] = function readChapterFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags:Object,\r\n  id3header?: TagHeader\r\n): any {\r\n  var originalOffset = offset;\r\n  var result = {};\r\n  var id = StringUtils.readNullTerminatedString(data.getBytesAt(offset, length));\r\n  result.id = id.toString();\r\n  offset += id.bytesReadCount;\r\n  result.startTime = data.getLongAt(offset, true);\r\n  offset+=4;\r\n  result.endTime = data.getLongAt(offset, true);\r\n  offset+=4;\r\n  result.startOffset = data.getLongAt(offset, true);\r\n  offset+=4;\r\n  result.endOffset = data.getLongAt(offset, true);\r\n  offset+=4;\r\n\r\n  var remainingLength = length - (offset - originalOffset);\r\n  result.subFrames = this.readFrames(offset, offset + remainingLength, data, id3header);\r\n  return result;\r\n};\r\n\r\n// ID3v2 table of contents according to http://id3.org/id3v2-chapters-1.0\r\nframeReaderFunctions['CTOC'] = function readTableOfContentsFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags:Object,\r\n  id3header?: TagHeader\r\n): any {\r\n  var originalOffset = offset;\r\n  var result = { childElementIds: [], id: undefined, topLevel: undefined, ordered: undefined, entryCount: undefined, subFrames: undefined };\r\n  var id = StringUtils.readNullTerminatedString(data.getBytesAt(offset, length));\r\n  result.id = id.toString();\r\n  offset += id.bytesReadCount;\r\n  result.topLevel = data.isBitSetAt(offset, 1);\r\n  result.ordered = data.isBitSetAt(offset, 0);\r\n  offset++;\r\n  result.entryCount = data.getByteAt(offset);\r\n  offset++;\r\n  for (var i = 0; i < result.entryCount; i++) {\r\n    var childId = StringUtils.readNullTerminatedString(data.getBytesAt(offset, length - (offset - originalOffset)));\r\n    result.childElementIds.push(childId.toString());\r\n    offset += childId.bytesReadCount;\r\n  }\r\n\r\n  var remainingLength = length - (offset - originalOffset);\r\n  result.subFrames = this.readFrames(offset, offset + remainingLength, data, id3header);\r\n  return result;\r\n}\r\n\r\nframeReaderFunctions['COMM'] = function readCommentsFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags:Object,\r\n  id3header?: TagHeader\r\n): any {\r\n  var start = offset;\r\n  var charset = getTextEncoding(data.getByteAt(offset));\r\n  var language = data.getStringAt( offset+1, 3 );\r\n  var shortdesc = data.getStringWithCharsetAt(offset+4, length-4, charset);\r\n\r\n  offset += 4 + shortdesc.bytesReadCount;\r\n  var text = data.getStringWithCharsetAt( offset, (start+length) - offset, charset );\r\n\r\n  return {\r\n    language : language,\r\n    short_description : shortdesc.toString(),\r\n    text : text.toString()\r\n  };\r\n};\r\n\r\nframeReaderFunctions['COM'] = frameReaderFunctions['COMM'];\r\n\r\nframeReaderFunctions['PIC'] = function(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags:Object,\r\n  id3header?: TagHeader\r\n): any {\r\n  return frameReaderFunctions['APIC'](offset, length, data, flags, id3header);\r\n};\r\n\r\nframeReaderFunctions['PCNT'] = function readCounterFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags:Object,\r\n  id3header?: TagHeader\r\n): any {\r\n  // FIXME: implement the rest of the spec\r\n  return data.getLongAt(offset, false);\r\n};\r\n\r\nframeReaderFunctions['CNT'] = frameReaderFunctions['PCNT'];\r\n\r\nframeReaderFunctions['T*'] = function readTextFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags:Object,\r\n  id3header?: TagHeader\r\n): any {\r\n  var charset = getTextEncoding(data.getByteAt(offset));\r\n\r\n  return data.getStringWithCharsetAt(offset+1, length-1, charset).toString();\r\n};\r\n\r\nframeReaderFunctions['TXXX'] = function readTextFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags:Object,\r\n  id3header?: TagHeader\r\n): Object {\r\n  var charset = getTextEncoding(data.getByteAt(offset));\r\n\r\n  return getUserDefinedFields(offset, length, data, charset);\r\n};\r\n\r\nframeReaderFunctions['WXXX'] = function readUrlFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags: Object,\r\n  id3header?: TagHeader\r\n):Object {\r\n  if (length === 0) {\r\n    return null;\r\n  }\r\n  var charset = getTextEncoding(data.getByteAt(offset));\r\n  return getUserDefinedFields(offset, length, data, charset);\r\n};\r\n\r\nframeReaderFunctions['W*'] = function readUrlFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags: Object,\r\n  id3header?: TagHeader\r\n):string {\r\n  if (length === 0) {\r\n    return null;\r\n  }\r\n  return data.getStringWithCharsetAt(offset, length, 'iso-8859-1').toString();\r\n};\r\n\r\nframeReaderFunctions['TCON'] = function readGenreFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags?: Object\r\n): any {\r\n  var text = frameReaderFunctions['T*'].apply(this, arguments);\r\n  return text.replace(/^\\(\\d+\\)/, '');\r\n};\r\n\r\nframeReaderFunctions['TCO'] = frameReaderFunctions['TCON'];\r\n\r\nframeReaderFunctions['USLT'] = function readLyricsFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags: Object,\r\n  id3header?: TagHeader\r\n): any {\r\n  var start = offset;\r\n  var charset = getTextEncoding(data.getByteAt(offset));\r\n  var language = data.getStringAt(offset+1, 3);\r\n  var descriptor = data.getStringWithCharsetAt(offset+4, length-4, charset);\r\n\r\n  offset += 4 + descriptor.bytesReadCount;\r\n  var lyrics = data.getStringWithCharsetAt( offset, (start+length) - offset, charset );\r\n\r\n  return {\r\n    language : language,\r\n    descriptor : descriptor.toString(),\r\n    lyrics : lyrics.toString()\r\n  };\r\n};\r\n\r\nframeReaderFunctions['ULT'] = frameReaderFunctions['USLT'];\r\n\r\nframeReaderFunctions['UFID'] = function readLyricsFrame(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  flags:Object,\r\n  id3header?: TagHeader\r\n): any {\r\n  var ownerIdentifier =\r\n    StringUtils.readNullTerminatedString(data.getBytesAt(offset, length));\r\n  offset += ownerIdentifier.bytesReadCount;\r\n  var identifier = data.getBytesAt(\r\n    offset, length - ownerIdentifier.bytesReadCount\r\n  );\r\n\r\n  return {\r\n    ownerIdentifier: ownerIdentifier.toString(),\r\n    identifier: identifier\r\n  };\r\n};\r\n\r\nfunction getTextEncoding(bite): CharsetType {\r\n  var charset:CharsetType;\r\n\r\n  switch (bite)\r\n  {\r\n    case 0x00:\r\n    charset = 'iso-8859-1';\r\n    break;\r\n\r\n    case 0x01:\r\n    charset = 'utf-16';\r\n    break;\r\n\r\n    case 0x02:\r\n    charset = 'utf-16be';\r\n    break;\r\n\r\n    case 0x03:\r\n    charset = 'utf-8';\r\n    break;\r\n\r\n    default:\r\n    charset = 'iso-8859-1';\r\n  }\r\n\r\n  return charset;\r\n}\r\n\r\n// Handles reading description/data from either http://id3.org/id3v2.3.0#User_defined_text_information_frame\r\n// and http://id3.org/id3v2.3.0#User_defined_URL_link_frame\r\nfunction getUserDefinedFields(\r\n  offset: number,\r\n  length: number,\r\n  data: MediaFileReader,\r\n  charset: CharsetType\r\n): Object {\r\n  var userDesc = data.getStringWithCharsetAt(offset + 1, length - 1, charset);\r\n  var userDefinedData = data.getStringWithCharsetAt(offset + 1 + userDesc.bytesReadCount, length - 1 - userDesc.bytesReadCount, charset);\r\n\r\n  return {\r\n    user_description: userDesc.toString(),\r\n    data: userDefinedData.toString()\r\n  };\r\n}\r\n\r\nvar PICTURE_TYPE = [\r\n  \"Other\",\r\n  \"32x32 pixels 'file icon' (PNG only)\",\r\n  \"Other file icon\",\r\n  \"Cover (front)\",\r\n  \"Cover (back)\",\r\n  \"Leaflet page\",\r\n  \"Media (e.g. label side of CD)\",\r\n  \"Lead artist/lead performer/soloist\",\r\n  \"Artist/performer\",\r\n  \"Conductor\",\r\n  \"Band/Orchestra\",\r\n  \"Composer\",\r\n  \"Lyricist/text writer\",\r\n  \"Recording Location\",\r\n  \"During recording\",\r\n  \"During performance\",\r\n  \"Movie/video screen capture\",\r\n  \"A bright coloured fish\",\r\n  \"Illustration\",\r\n  \"Band/artist logotype\",\r\n  \"Publisher/Studio logotype\"\r\n];\r\n\r\nexport default ID3v2FrameReader;\r\n","\r\n\r\n\r\nimport MediaFileReader from './MediaFileReader';\r\n\r\nimport type {\r\n  CallbackType,\r\n  LoadCallbackType,\r\n  TagFrames,\r\n  TagHeader,\r\n  TagFrameHeader,\r\n  TagFrameFlags,\r\n  CharsetType,\r\n  ByteRange,\r\n  TagType,\r\n} from './FlowTypes';\r\nimport ID3v2FrameReader from './ID3v2FrameReader';\r\nimport MediaTagReader from './MediaTagReader';\r\n\r\nconst ID3_HEADER_SIZE = 10;\r\n\r\nclass ID3v2TagReader extends MediaTagReader {\r\n  static getTagIdentifierByteRange(): ByteRange {\r\n    // ID3 header\r\n    return {\r\n      offset: 0,\r\n      length: ID3_HEADER_SIZE\r\n    };\r\n  }\r\n\r\n  static canReadTagFormat(tagIdentifier: Array<number>): boolean {\r\n    var id = String.fromCharCode.apply(String, tagIdentifier.slice(0, 3));\r\n    return id === 'ID3';\r\n  }\r\n\r\n  _loadData(mediaFileReader: MediaFileReader, callbacks: LoadCallbackType) {\r\n    mediaFileReader.loadRange([6, 9], {\r\n      onSuccess: function() {\r\n        mediaFileReader.loadRange(\r\n          // The tag size does not include the header size.\r\n          [0, ID3_HEADER_SIZE + mediaFileReader.getSynchsafeInteger32At(6) - 1],\r\n          callbacks\r\n        );\r\n      },\r\n      onError: callbacks.onError\r\n    });\r\n  }\r\n\r\n  _parseData(data: MediaFileReader, tags?: Array<string>): TagType {\r\n    var offset = 0;\r\n    var major = data.getByteAt(offset+3);\r\n    if (major > 4) { return {\"type\": \"ID3\", \"version\": \">2.4\", \"tags\": {}}; }\r\n    var revision = data.getByteAt(offset+4);\r\n    var unsynch = data.isBitSetAt(offset+5, 7);\r\n    var xheader = data.isBitSetAt(offset+5, 6);\r\n    var xindicator = data.isBitSetAt(offset+5, 5);\r\n    var size = data.getSynchsafeInteger32At(offset+6);\r\n    offset += 10;\r\n\r\n    if( xheader ) {\r\n      // We skip the extended header and don't offer support for it right now.\r\n      if (major === 4) {\r\n        var xheadersize = data.getSynchsafeInteger32At(offset);\r\n        offset += xheadersize;\r\n      } else {\r\n        var xheadersize = data.getLongAt(offset, true);\r\n        // The 'Extended header size', currently 6 or 10 bytes, excludes itself.\r\n        offset += xheadersize + 4;\r\n      }\r\n    }\r\n\r\n    var id3 = {\r\n      \"type\": \"ID3\",\r\n      \"version\" : '2.' + major + '.' + revision,\r\n      \"major\" : major,\r\n      \"revision\" : revision,\r\n      \"flags\" : {\r\n        \"unsynchronisation\" : unsynch,\r\n        \"extended_header\" : xheader,\r\n        \"experimental_indicator\" : xindicator,\r\n        // TODO: footer_present\r\n        \"footer_present\" : false\r\n      },\r\n      \"size\" : size,\r\n      \"tags\": {},\r\n    };\r\n\r\n    if (tags) {\r\n      var expandedTags = this._expandShortcutTags(tags);\r\n    }\r\n\r\n    var offsetEnd = size + 10/*header size*/;\r\n    // When this flag is set the entire tag needs to be un-unsynchronised\r\n    // before parsing each individual frame. Individual frame sizes might not\r\n    // take unsynchronisation into consideration when it's set on the tag\r\n    // header.\r\n    if (id3.flags.unsynchronisation) {\r\n      data = ID3v2FrameReader.getUnsyncFileReader(data, offset, size);\r\n      offset = 0;\r\n      offsetEnd = data.getSize();\r\n    }\r\n\r\n    var frames = ID3v2FrameReader.readFrames(offset, offsetEnd, data, id3, expandedTags);\r\n    // create shortcuts for most common data.\r\n    for (var name in SHORTCUTS) if (SHORTCUTS.hasOwnProperty(name)) {\r\n      var frameData = this._getFrameData(frames, SHORTCUTS[name]);\r\n      if (frameData) {\r\n        id3.tags[name] = frameData;\r\n      }\r\n    }\r\n\r\n    for (var frame in frames) if (frames.hasOwnProperty(frame)) {\r\n      id3.tags[frame] = frames[frame];\r\n    }\r\n\r\n    return id3;\r\n  }\r\n\r\n  _getFrameData(frames: TagFrames, ids: Array<string>): Object {\r\n    var frame;\r\n    for (var i = 0, id; id = ids[i]; i++) {\r\n      if (id in frames) {\r\n        if (frames[id] instanceof Array) {\r\n          frame = frames[id][0];\r\n        } else {\r\n          frame = frames[id];\r\n        }\r\n        return frame.data;\r\n      }\r\n    }\r\n  }\r\n\r\n  getShortcuts(): {[key: string]: string|Array<string>} {\r\n    return SHORTCUTS;\r\n  }\r\n}\r\n\r\n\r\nconst SHORTCUTS = {\r\n  \"title\"     : [\"TIT2\", \"TT2\"],\r\n  \"artist\"    : [\"TPE1\", \"TP1\"],\r\n  \"album\"     : [\"TALB\", \"TAL\"],\r\n  \"year\"      : [\"TYER\", \"TYE\"],\r\n  \"comment\"   : [\"COMM\", \"COM\"],\r\n  \"track\"     : [\"TRCK\", \"TRK\"],\r\n  \"genre\"     : [\"TCON\", \"TCO\"],\r\n  \"picture\"   : [\"APIC\", \"PIC\"],\r\n  \"lyrics\"    : [\"USLT\", \"ULT\"]\r\n};\r\n\r\nexport default ID3v2TagReader;\r\n","/**\r\n * Support for iTunes-style m4a tags\r\n * See:\r\n *   http://atomicparsley.sourceforge.net/mpeg-4files.html\r\n *   http://developer.apple.com/mac/library/documentation/QuickTime/QTFF/Metadata/Metadata.html\r\n * Authored by Joshua Kifer <joshua.kifer gmail.com>\r\n * @flow\r\n */\r\n\r\n\r\nimport MediaFileReader from './MediaFileReader';\r\n\r\nimport type {\r\n  CallbackType,\r\n  LoadCallbackType,\r\n  CharsetType,\r\n  ByteRange,\r\n  TagType,\r\n  TagFrame\r\n} from './FlowTypes';\r\nimport MediaTagReader from './MediaTagReader';\r\n\r\nclass MP4TagReader extends MediaTagReader {\r\n  static getTagIdentifierByteRange(): ByteRange {\r\n    // The tag identifier is located in [4, 8] but since we'll need to reader\r\n    // the header of the first block anyway, we load it instead to avoid\r\n    // making two requests.\r\n    return {\r\n      offset: 0,\r\n      length: 16\r\n    };\r\n  }\r\n\r\n  static canReadTagFormat(tagIdentifier: Array<number>): boolean {\r\n    var id = String.fromCharCode.apply(String, tagIdentifier.slice(4, 8));\r\n    return id === \"ftyp\";\r\n  }\r\n\r\n  _loadData(mediaFileReader: MediaFileReader, callbacks: LoadCallbackType) {\r\n    // MP4 metadata isn't located in a specific location of the file. Roughly\r\n    // speaking, it's composed of blocks chained together like a linked list.\r\n    // These blocks are called atoms (or boxes).\r\n    // Each atom of the list can have its own child linked list. Atoms in this\r\n    // situation do not possess any data and are called \"container\" as they only\r\n    // contain other atoms.\r\n    // Other atoms represent a particular set of data, like audio, video or\r\n    // metadata. In order to find and load all the interesting atoms we need\r\n    // to traverse the entire linked list of atoms and only load the ones\r\n    // associated with metadata.\r\n    // The metadata atoms can be find under the \"moov.udta.meta.ilst\" hierarchy.\r\n\r\n    var self = this;\r\n    // Load the header of the first atom\r\n    mediaFileReader.loadRange([0, 16], {\r\n      onSuccess: function() {\r\n        self._loadAtom(mediaFileReader, 0, \"\", callbacks);\r\n      },\r\n      onError: callbacks.onError\r\n    });\r\n  }\r\n\r\n  _loadAtom(\r\n    mediaFileReader: MediaFileReader,\r\n    offset: number,\r\n    parentAtomFullName: string,\r\n    callbacks: LoadCallbackType\r\n  ) {\r\n    if (offset >= mediaFileReader.getSize()) {\r\n      callbacks.onSuccess();\r\n      return;\r\n    }\r\n\r\n    var self = this;\r\n    // 8 is the size of the atomSize and atomName fields.\r\n    // When reading the current block we always read 8 more bytes in order\r\n    // to also read the header of the next block.\r\n    var atomSize = mediaFileReader.getLongAt(offset, true);\r\n    if (atomSize == 0 || isNaN(atomSize)) {\r\n      callbacks.onSuccess();\r\n      return;\r\n    }\r\n    var atomName = mediaFileReader.getStringAt(offset + 4, 4);\r\n    // console.log(parentAtomFullName, atomName, atomSize);\r\n    // Container atoms (no actual data)\r\n    if (this._isContainerAtom(atomName)) {\r\n      if (atomName == \"meta\") {\r\n        // The \"meta\" atom breaks convention and is a container with data.\r\n        offset += 4; // next_item_id (uint32)\r\n      }\r\n      var atomFullName = (parentAtomFullName ? parentAtomFullName+\".\" : \"\") + atomName;\r\n      if (atomFullName === \"moov.udta.meta.ilst\") {\r\n        mediaFileReader.loadRange([offset, offset + atomSize], callbacks);\r\n      } else {\r\n        mediaFileReader.loadRange([offset+8, offset+8 + 8], {\r\n          onSuccess: function() {\r\n            self._loadAtom(mediaFileReader, offset + 8, atomFullName, callbacks);\r\n          },\r\n          onError: callbacks.onError\r\n        });\r\n      }\r\n    } else {\r\n      mediaFileReader.loadRange([offset+atomSize, offset+atomSize + 8], {\r\n        onSuccess: function() {\r\n          self._loadAtom(mediaFileReader, offset+atomSize, parentAtomFullName, callbacks);\r\n        },\r\n        onError: callbacks.onError\r\n      });\r\n    }\r\n  }\r\n\r\n  _isContainerAtom(atomName: string): boolean {\r\n    return [\"moov\", \"udta\", \"meta\", \"ilst\"].indexOf(atomName) >= 0;\r\n  }\r\n\r\n  _canReadAtom(atomName: string): boolean {\r\n    //return atomName !== \"----\";\r\n    return true\r\n  }\r\n\r\n  _parseData(data: MediaFileReader, tagsToRead: Array<string>): TagType {\r\n    var tags = {};\r\n\r\n    tagsToRead = this._expandShortcutTags(tagsToRead);\r\n    this._readAtom(tags, data, 0, data.getSize(), tagsToRead);\r\n\r\n    // create shortcuts for most common data.\r\n    for (var name in SHORTCUTS) if (SHORTCUTS.hasOwnProperty(name)) {\r\n      var tag = tags[SHORTCUTS[name]];\r\n      if (tag) {\r\n        if (name === \"track\") {\r\n          tags[name] = tag.data.track;\r\n        } else {\r\n          tags[name] = tag.data;\r\n        }\r\n      }\r\n    }\r\n\r\n    return {\r\n      \"type\": \"MP4\",\r\n      \"ftyp\": data.getStringAt(8, 4),\r\n      \"version\": data.getLongAt(12, true),\r\n      \"tags\": tags\r\n    };\r\n  }\r\n\r\n  _readAtom(\r\n    tags: Object,\r\n    data: MediaFileReader,\r\n    offset: number,\r\n    length: number,\r\n    tagsToRead:Array<string>,\r\n    parentAtomFullName?: string,\r\n    indent?: string\r\n  ) {\r\n    indent = indent === undefined ? \"\" : indent + \"  \";\r\n\r\n    var seek = offset;\r\n    while (seek < offset + length) {\r\n      var atomSize = data.getLongAt(seek, true);\r\n      if (atomSize == 0) {\r\n        return;\r\n      }\r\n      var atomName = data.getStringAt(seek + 4, 4);\r\n\r\n      // console.log(seek, parentAtomFullName, atomName, atomSize);\r\n      if (this._isContainerAtom(atomName)) {\r\n        if (atomName == \"meta\") {\r\n          seek += 4; // next_item_id (uint32)\r\n        }\r\n        var atomFullName = (parentAtomFullName ? parentAtomFullName+\".\" : \"\") + atomName;\r\n        this._readAtom(tags, data, seek + 8, atomSize - 8, tagsToRead, atomFullName, indent);\r\n        return;\r\n      }\r\n\r\n      // Value atoms\r\n      if (\r\n        (!tagsToRead || tagsToRead.indexOf(atomName) >= 0) &&\r\n        parentAtomFullName === \"moov.udta.meta.ilst\" &&\r\n        this._canReadAtom(atomName)\r\n      ) {\r\n        if(atomName === '----')\r\n          {\r\n            let atomData = this._readMeanMetadataAtom(data, seek);\r\n            tags[atomData.id] = atomData;\r\n          }\r\n          else\r\n          {\r\n            tags[atomName] = this._readMetadataAtom(data, seek);\r\n          }\r\n        \r\n      }\r\n\r\n      seek += atomSize;\r\n    }\r\n  }\r\n\r\n  _readMetadataAtom(data: MediaFileReader, offset: number): TagFrame {\r\n    // 16: size + name + size + \"data\" (4 bytes each)\r\n    // 8: 1 byte atom version & 3 bytes atom flags + 4 bytes NULL space\r\n    // 8: 4 bytes track + 4 bytes total\r\n    const METADATA_HEADER = 16;\r\n\r\n    var atomSize = data.getLongAt(offset, true);\r\n    var atomName = data.getStringAt(offset + 4, 4);\r\n\r\n    var klass = data.getInteger24At(offset + METADATA_HEADER + 1, true);\r\n    var type = TYPES[klass];\r\n    var atomData;\r\n    var bigEndian = true;\r\n    if (atomName == \"trkn\") {\r\n      atomData = {\r\n        \"track\": data.getShortAt(offset + METADATA_HEADER + 10, bigEndian),\r\n        \"total\": data.getShortAt(offset + METADATA_HEADER + 14, bigEndian)\r\n      };\r\n    } else if (atomName == \"disk\") {\r\n      atomData = {\r\n        \"disk\": data.getShortAt(offset + METADATA_HEADER + 10, bigEndian),\r\n        \"total\": data.getShortAt(offset + METADATA_HEADER + 14, bigEndian)\r\n      };\r\n    } else {\r\n      // 4: atom version (1 byte) + atom flags (3 bytes)\r\n      // 4: NULL (usually locale indicator)\r\n      var atomHeader = METADATA_HEADER + 4 + 4;\r\n      var dataStart = offset + atomHeader;\r\n      var dataLength = atomSize - atomHeader;\r\n      var atomData;\r\n\r\n      // Workaround for covers being parsed as 'uint8' type despite being an 'covr' atom\r\n      if (atomName === 'covr' && type === 'uint8') {\r\n        type = 'jpeg'\r\n      }\r\n\r\n      switch (type) {\r\n        case \"text\":\r\n        atomData = data.getStringWithCharsetAt(dataStart, dataLength, \"utf-8\").toString();\r\n        break;\r\n\r\n        case \"uint8\":\r\n        atomData = data.getShortAt(dataStart, false);\r\n        break;\r\n        \r\n        case \"int\":\r\n        case \"uint\":\r\n        // Though the QuickTime spec doesn't state it, there are 64-bit values\r\n        // such as plID (Playlist/Collection ID). With its single 64-bit floating\r\n        // point number type, these are hard to parse and pass in JavaScript.\r\n        // The high word of plID seems to always be zero, so, as this is the\r\n        // only current 64-bit atom handled, it is parsed from its 32-bit\r\n        // low word as an unsigned long.\r\n        //\r\n        var intReader = type == 'int'\r\n                          ? ( dataLength == 1 ? data.getSByteAt :\r\n                              dataLength == 2 ? data.getSShortAt :\r\n                              dataLength == 4 ? data.getSLongAt :\r\n                                                data.getLongAt)\r\n                          : ( dataLength == 1 ? data.getByteAt :\r\n                              dataLength == 2 ? data.getShortAt :\r\n                                                data.getLongAt);\r\n        // $FlowFixMe - getByteAt doesn't receive a second argument\r\n        atomData = intReader.call(data, dataStart + (dataLength == 8 ? 4 : 0), true);\r\n        break;\r\n\r\n        case \"jpeg\":\r\n        case \"png\":\r\n        atomData = {\r\n          \"format\": \"image/\" + type,\r\n          \"data\": data.getBytesAt(dataStart, dataLength)\r\n        };\r\n        break;\r\n      }\r\n    }\r\n\r\n    return {\r\n      id: atomName,\r\n      size: atomSize,\r\n      description: ATOM_DESCRIPTIONS[atomName] || \"Unknown\",\r\n      data: atomData\r\n    };\r\n  }\r\n\r\n  _readMeanMetadataAtom(data: MediaFileReader, offset: number): TagFrame {\r\n    // 16: size + name + size + \"data\" (4 bytes each)\r\n    // 8: 1 byte atom version & 3 bytes atom flags + 4 bytes NULL space\r\n    // 8: 4 bytes track + 4 bytes total\r\n    var METADATA_HEADER = 16;\r\n    var atomSize = data.getLongAt(offset, true);\r\n    var atomName = data.getStringAt(offset + 4, 4);\r\n    let description = '';\r\n    var klass = data.getInteger24At(offset + METADATA_HEADER + 1, true);\r\n    var type = TYPES[klass];\r\n    var atomData;\r\n    var bigEndian = true;\r\n\r\n    if(atomName == \"----\")\r\n    {\r\n      let parentAtomName = atomName;\r\n      let atomOffset = offset + 8;\r\n      atomSize = data.getLongAt(atomOffset, true);\r\n      atomName = data.getStringAt(atomOffset + 4, 4);\r\n      parentAtomName += '/' + atomName;\r\n\r\n      if(atomName === \"mean\")\r\n      {\r\n        atomOffset += 8;\r\n        atomName = data.getStringAt(atomOffset + 4, atomSize - 12); // com.apple.iTunes | com.serato.dj\r\n        //console.log('atomSize', atomSize);\r\n        //console.log('atomName', atomName);\r\n        parentAtomName += '/' + atomName;\r\n\r\n        atomOffset = offset + atomSize + 8;\r\n        atomSize = data.getLongAt(atomOffset, true);\r\n        atomName = data.getStringAt(atomOffset + 4, 4); // 'name'\r\n        //console.log('atomSize', atomSize);\r\n        //console.log('atomName', atomName);\r\n\r\n        if(atomName === \"name\")\r\n        {\r\n          //atomOffset += 8;\r\n          atomName = data.getStringAt(atomOffset + 12, atomSize - 12); // 'markersv2'\r\n          parentAtomName += '/' + atomName;\r\n          description = atomName;\r\n          //console.log('atomSize', atomSize);\r\n          //console.log('atomName', atomName);\r\n\r\n          atomOffset += atomSize;\r\n          atomSize = data.getLongAt(atomOffset, true);\r\n          atomName = data.getStringAt(atomOffset + 4, 4); // 'data'\r\n          //console.log('atomSize', atomSize);\r\n          //console.log('atomName', atomName);\r\n          \r\n          var dataStart = atomOffset + METADATA_HEADER;\r\n          var dataLength = atomSize - METADATA_HEADER;\r\n          //console.log('atomOffset', atomOffset, 'atomSize', atomSize, 'dataStart', dataStart, 'dataLength', dataLength);\r\n          atomData = data.getStringWithCharsetAt(dataStart, dataLength, \"utf-8\").toString();\r\n          return {\r\n            id: parentAtomName,\r\n            size: atomSize,\r\n            description: description,\r\n            data: atomData\r\n          };\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  getShortcuts(): {[key: string]: string|Array<string>} {\r\n    return SHORTCUTS;\r\n  }\r\n}\r\n\r\n/*\r\n * https://developer.apple.com/library/content/documentation/QuickTime/QTFF/Metadata/Metadata.html#//apple_ref/doc/uid/TP40000939-CH1-SW35\r\n*/\r\nconst TYPES = {\r\n  \"0\": \"uint8\",\r\n  \"1\": \"text\",\r\n  \"13\": \"jpeg\",\r\n  \"14\": \"png\",\r\n  \"21\": \"int\",\r\n  \"22\": \"uint\"\r\n};\r\n\r\nconst ATOM_DESCRIPTIONS = {\r\n  \"alb\": \"Album\",\r\n  \"ART\": \"Artist\",\r\n  \"aART\": \"Album Artist\",\r\n  \"day\": \"Release Date\",\r\n  \"nam\": \"Title\",\r\n  \"gen\": \"Genre\",\r\n  \"gnre\": \"Genre\",\r\n  \"trkn\": \"Track Number\",\r\n  \"wrt\": \"Composer\",\r\n  \"too\": \"Encoding Tool\",\r\n  \"enc\": \"Encoded By\",\r\n  \"cprt\": \"Copyright\",\r\n  \"covr\": \"Cover Art\",\r\n  \"grp\": \"Grouping\",\r\n  \"keyw\": \"Keywords\",\r\n  \"lyr\": \"Lyrics\",\r\n  \"cmt\": \"Comment\",\r\n  \"tmpo\": \"Tempo\",\r\n  \"cpil\": \"Compilation\",\r\n  \"disk\": \"Disc Number\",\r\n  \"tvsh\": \"TV Show Name\",\r\n  \"tven\": \"TV Episode ID\",\r\n  \"tvsn\": \"TV Season\",\r\n  \"tves\": \"TV Episode\",\r\n  \"tvnn\": \"TV Network\",\r\n  \"desc\": \"Description\",\r\n  \"ldes\": \"Long Description\",\r\n  \"sonm\": \"Sort Name\",\r\n  \"soar\": \"Sort Artist\",\r\n  \"soaa\": \"Sort Album\",\r\n  \"soco\": \"Sort Composer\",\r\n  \"sosn\": \"Sort Show\",\r\n  \"purd\": \"Purchase Date\",\r\n  \"pcst\": \"Podcast\",\r\n  \"purl\": \"Podcast URL\",\r\n  \"catg\": \"Category\",\r\n  \"hdvd\": \"HD Video\",\r\n  \"stik\": \"Media Type\",\r\n  \"rtng\": \"Content Rating\",\r\n  \"pgap\": \"Gapless Playback\",\r\n  \"apID\": \"Purchase Account\",\r\n  \"sfID\": \"Country Code\",\r\n  \"atID\": \"Artist ID\",\r\n  \"cnID\": \"Catalog ID\",\r\n  \"plID\": \"Collection ID\",\r\n  \"geID\": \"Genre ID\",\r\n  \"xid \": \"Vendor Information\",\r\n  \"flvr\": \"Codec Flavor\"\r\n};\r\n\r\nconst UNSUPPORTED_ATOMS = {\r\n  \"----\": 1,\r\n};\r\n\r\nconst SHORTCUTS = {\r\n  \"title\"     : \"nam\",\r\n  \"artist\"    : \"ART\",\r\n  \"album\"     : \"alb\",\r\n  \"year\"      : \"day\",\r\n  \"comment\"   : \"cmt\",\r\n  \"track\"     : \"trkn\",\r\n  \"genre\"     : \"gen\",\r\n  \"picture\"   : \"covr\",\r\n  \"lyrics\"    : \"lyr\"\r\n};\r\n\r\nexport default MP4TagReader;\r\n","import MediaFileReader from './MediaFileReader';\r\n\r\n/* The first 4 bytes of a FLAC file describes the header for the file. If these\r\n * bytes respectively read \"fLaC\", we can determine it is a FLAC file.\r\n */\r\nconst FLAC_HEADER_SIZE = 4;\r\n\r\n/* FLAC metadata is stored in blocks containing data ranging from STREAMINFO to\r\n * VORBIS_COMMENT, which is what we want to work with.\r\n *\r\n * Each metadata header is 4 bytes long, with the first byte determining whether\r\n * it is the last metadata block before the audio data and what the block type is.\r\n * This first byte can further be split into 8 bits, with the first bit being the\r\n * last-metadata-block flag, and the last three bits being the block type.\r\n *\r\n * Since the specification states that the decimal value for a VORBIS_COMMENT block\r\n * type is 4, the two possibilities for the comment block header values are:\r\n * - 00000100 (Not a last metadata comment block, value of 4)\r\n * - 10000100 (A last metadata comment block, value of 132)\r\n *\r\n * Similarly, the picture block header values are 6 and 128.\r\n *\r\n * All values for METADATA_BLOCK_HEADER can be found here.\r\n * https://xiph.org/flac/format.html#metadata_block_header\r\n */\r\nconst COMMENT_HEADERS = [4, 132];\r\nconst PICTURE_HEADERS = [6, 134];\r\n\r\n// These are the possible image types as defined by the FLAC specification.\r\nconst IMAGE_TYPES = [\r\n  \"Other\",\r\n  \"32x32 pixels 'file icon' (PNG only)\",\r\n  \"Other file icon\",\r\n  \"Cover (front)\",\r\n  \"Cover (back)\",\r\n  \"Leaflet page\",\r\n  \"Media (e.g. label side of CD)\",\r\n  \"Lead artist/lead performer/soloist\",\r\n  \"Artist/performer\",\r\n  \"Conductor\",\r\n  \"Band/Orchestra\",\r\n  \"Composer\",\r\n  \"Lyricist/text writer\",\r\n  \"Recording Location\",\r\n  \"During recording\",\r\n  \"During performance\",\r\n  \"Movie/video screen capture\",\r\n  \"A bright coloured fish\",\r\n  \"Illustration\",\r\n  \"Band/artist logotype\",\r\n  \"Publisher/Studio logotype\"\r\n];\r\n\r\nimport type {\r\n  LoadCallbackType,\r\n  ByteRange,\r\n  TagType\r\n} from './FlowTypes';\r\nimport MediaTagReader from './MediaTagReader';\r\n\r\n/**\r\n * Class representing a MediaTagReader that parses FLAC tags.\r\n */\r\nclass FLACTagReader extends MediaTagReader {\r\n  _commentOffset: number;\r\n  _pictureOffset: number;\r\n\r\n  /**\r\n   * Gets the byte range for the tag identifier.\r\n   *\r\n   * Because the Vorbis comment block is not guaranteed to be in a specified\r\n   * location, we can only load the first 4 bytes of the file to confirm it\r\n   * is a FLAC first.\r\n   *\r\n   * @return {ByteRange} The byte range that identifies the tag for a FLAC.\r\n   */\r\n  static getTagIdentifierByteRange(): ByteRange {\r\n    return {\r\n      offset: 0,\r\n      length: FLAC_HEADER_SIZE\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Determines whether or not this reader can read a certain tag format.\r\n   *\r\n   * This checks that the first 4 characters in the file are fLaC, which\r\n   * according to the FLAC file specification should be the characters that\r\n   * indicate a FLAC file.\r\n   *\r\n   * @return {boolean} True if the header is fLaC, false otherwise.\r\n   */\r\n  static canReadTagFormat(tagIdentifier: Array<number>): boolean {\r\n    var id = String.fromCharCode.apply(String, tagIdentifier.slice(0, 4));\r\n    return id === 'fLaC';\r\n  }\r\n\r\n  /**\r\n   * Function called to load the data from the file.\r\n   *\r\n   * To begin processing the blocks, the next 4 bytes after the initial 4 bytes\r\n   * (bytes 4 through 7) are loaded. From there, the rest of the loading process\r\n   * is passed on to the _loadBlock function, which will handle the rest of the\r\n   * parsing for the metadata blocks.\r\n   *\r\n   * @param {MediaFileReader} mediaFileReader - The MediaFileReader used to parse the file.\r\n   * @param {LoadCallbackType} callbacks - The callback to call once _loadData is completed.\r\n   */\r\n  _loadData(mediaFileReader: MediaFileReader, callbacks: LoadCallbackType) {\r\n    var self = this;\r\n    mediaFileReader.loadRange([4, 7], {\r\n      onSuccess: function() {\r\n        self._loadBlock(mediaFileReader, 4, callbacks);\r\n      }\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Special internal function used to parse the different FLAC blocks.\r\n   *\r\n   * The FLAC specification doesn't specify a specific location for metadata to resign, but\r\n   * dictates that it may be in one of various blocks located throughout the file. To load the\r\n   * metadata, we must locate the header first. This can be done by reading the first byte of\r\n   * each block to determine the block type. After the block type comes a 24 bit integer that stores\r\n   * the length of the block as big endian. Using this, we locate the block and store the offset for\r\n   * parsing later.\r\n   *\r\n   * After each block has been parsed, the _nextBlock function is called in order\r\n   * to parse the information of the next block. All blocks need to be parsed in order to find\r\n   * all of the picture and comment blocks.\r\n   *\r\n   * More info on the FLAC specification may be found here:\r\n   * https://xiph.org/flac/format.html\r\n   * @param {MediaFileReader} mediaFileReader - The MediaFileReader used to parse the file.\r\n   * @param {number} offset - The offset to start checking the header from.\r\n   * @param {LoadCallbackType} callbacks - The callback to call once the header has been found.\r\n   */\r\n  _loadBlock(\r\n    mediaFileReader: MediaFileReader,\r\n    offset: number,\r\n    callbacks: LoadCallbackType\r\n  ) {\r\n    var self = this;\r\n    /* As mentioned above, this first byte is loaded to see what metadata type\r\n     * this block represents.\r\n     */\r\n    var blockHeader = mediaFileReader.getByteAt(offset);\r\n    /* The last three bytes (integer 24) contain a value representing the length\r\n     * of the following metadata block. The 1 is added in order to shift the offset\r\n     * by one to get the last three bytes in the block header.\r\n     */\r\n    var blockSize = mediaFileReader.getInteger24At(offset + 1, true);\r\n    /* This conditional checks if blockHeader (the byte retrieved representing the\r\n     * type of the header) is one the headers we are looking for.\r\n     *\r\n     * If that is not true, the block is skipped over and the next range is loaded:\r\n     * - offset + 4 + blockSize adds 4 to skip over the initial metadata header and\r\n     * blockSize to skip over the block overall, placing it at the head of the next\r\n     * metadata header.\r\n     * - offset + 4 + 4 + blockSize does the same thing as the previous block with\r\n     * the exception of adding another 4 bytes to move it to the end of the new metadata\r\n     * header.\r\n     */\r\n    if (COMMENT_HEADERS.indexOf(blockHeader) !== -1) {\r\n      /* 4 is added to offset to move it to the head of the actual metadata.\r\n       * The range starting from offsetMatadata (the beginning of the block)\r\n       * and offsetMetadata + blockSize (the end of the block) is loaded.\r\n       */\r\n      var offsetMetadata = offset + 4;\r\n      mediaFileReader.loadRange([offsetMetadata, offsetMetadata + blockSize], {\r\n        onSuccess: function() {\r\n          self._commentOffset = offsetMetadata;\r\n          self._nextBlock(mediaFileReader, offset, blockHeader, blockSize, callbacks);\r\n        }\r\n      });\r\n    } else if (PICTURE_HEADERS.indexOf(blockHeader) !== -1) {\r\n      var offsetMetadata = offset + 4;\r\n      mediaFileReader.loadRange([offsetMetadata, offsetMetadata + blockSize], {\r\n        onSuccess: function() {\r\n          self._pictureOffset = offsetMetadata;\r\n          self._nextBlock(mediaFileReader, offset, blockHeader, blockSize, callbacks);\r\n        }\r\n      });\r\n    } else {\r\n      self._nextBlock(mediaFileReader, offset, blockHeader, blockSize, callbacks);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Internal function used to load the next range and respective block.\r\n   *\r\n   * If the metadata block that was identified is not the last block before the\r\n   * audio blocks, the function will continue loading the next blocks. If it is\r\n   * the last block (identified by any values greater than 127, see FLAC spec.),\r\n   * the function will determine whether a comment block had been identified.\r\n   *\r\n   * If the block does not exist, the error callback is called. Otherwise, the function\r\n   * will call the success callback, allowing data parsing to begin.\r\n   * @param {MediaFileReader} mediaFileReader - The MediaFileReader used to parse the file.\r\n   * @param {number} offset - The offset that the existing header was located at.\r\n   * @param {number} blockHeader - An integer reflecting the header type of the block.\r\n   * @param {number} blockSize - The size of the previously processed header.\r\n   * @param {LoadCallbackType} callbacks - The callback functions to be called.\r\n   */\r\n  _nextBlock(\r\n    mediaFileReader: MediaFileReader,\r\n    offset: number,\r\n    blockHeader: number,\r\n    blockSize: number,\r\n    callbacks: LoadCallbackType\r\n  ) {\r\n    var self = this;\r\n    if (blockHeader > 127) {\r\n      if (!self._commentOffset) {\r\n        callbacks.onError({\r\n          \"type\": \"loadData\",\r\n          \"info\": \"Comment block could not be found.\"\r\n        });\r\n      } else {\r\n        callbacks.onSuccess();\r\n      }\r\n    } else {\r\n      mediaFileReader.loadRange([offset + 4 + blockSize, offset + 4 + 4 + blockSize], {\r\n        onSuccess: function() {\r\n          self._loadBlock(mediaFileReader, offset + 4 + blockSize, callbacks);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parses the data and returns the tags.\r\n   *\r\n   * This is an overview of the VorbisComment format and what this function attempts to\r\n   * retrieve:\r\n   * - First 4 bytes: a long that contains the length of the vendor string.\r\n   * - Next n bytes: the vendor string encoded in UTF-8.\r\n   * - Next 4 bytes: a long representing how many comments are in this block\r\n   * For each comment that exists:\r\n   * - First 4 bytes: a long representing the length of the comment\r\n   * - Next n bytes: the comment encoded in UTF-8.\r\n   * The comment string will usually appear in a format similar to:\r\n   * ARTIST=me\r\n   *\r\n   * Note that the longs and integers in this block are encoded in little endian\r\n   * as opposed to big endian for the rest of the FLAC spec.\r\n   * @param {MediaFileReader} data - The MediaFileReader to parse the file with.\r\n   * @param {Array<string>} [tags] - Optional tags to also be retrieved from the file.\r\n   * @return {TagType} - An object containing the tag information for the file.\r\n   */\r\n  _parseData(data: MediaFileReader, tags:Array<string>): TagType {\r\n    var vendorLength = data.getLongAt(this._commentOffset, false);\r\n    var offsetVendor = this._commentOffset + 4;\r\n    /* This line is able to retrieve the vendor string that the VorbisComment block\r\n     * contains. However, it is not part of the tags that JSMediaTags normally retrieves,\r\n     * and is therefore commented out.\r\n     */\r\n    // var vendor = data.getStringWithCharsetAt(offsetVendor, vendorLength, \"utf-8\").toString();\r\n    var offsetList = vendorLength + offsetVendor;\r\n    /* To get the metadata from the block, we first get the long that contains the\r\n     * number of actual comment values that are existent within the block.\r\n     *\r\n     * As we loop through all of the comment blocks, we get the data length in order to\r\n     * get the right size string, and then determine which category that string falls under.\r\n     * The dataOffset variable is constantly updated so that it is at the beginning of the\r\n     * comment that is currently being parsed.\r\n     *\r\n     * Additions of 4 here are used to move the offset past the first 4 bytes which only contain\r\n     * the length of the comment.\r\n     */\r\n    var numComments = data.getLongAt(offsetList, false);\r\n    var dataOffset = offsetList + 4;\r\n    var title, artist, album, track, genre, picture;\r\n    for (let i = 0; i < numComments; i++) {\r\n      let dataLength = data.getLongAt(dataOffset, false);\r\n      let s = data.getStringWithCharsetAt(dataOffset + 4, dataLength, \"utf-8\").toString();\r\n      let d = s.indexOf(\"=\");\r\n      let split = [s.slice(0, d), s.slice(d + 1)];\r\n      switch (split[0].toUpperCase()) {\r\n        case \"TITLE\":\r\n          title = split[1];\r\n          break;\r\n        case \"ARTIST\":\r\n          artist = split[1];\r\n          break;\r\n        case \"ALBUM\":\r\n          album = split[1];\r\n          break;\r\n        case \"TRACKNUMBER\":\r\n          track = split[1];\r\n          break;\r\n        case \"GENRE\":\r\n          genre = split[1];\r\n          break;\r\n      }\r\n      dataOffset += 4 + dataLength;\r\n    }\r\n\r\n    /* If a picture offset was found and assigned, then the reader will start processing\r\n     * the picture block from that point.\r\n     *\r\n     * All the lengths for the picture data can be found online here:\r\n     * https://xiph.org/flac/format.html#metadata_block_picture\r\n     */\r\n    if (this._pictureOffset) {\r\n      var imageType = data.getLongAt(this._pictureOffset, true);\r\n      var offsetMimeLength = this._pictureOffset + 4;\r\n      var mimeLength = data.getLongAt(offsetMimeLength, true);\r\n      var offsetMime = offsetMimeLength + 4;\r\n      var mime = data.getStringAt(offsetMime, mimeLength);\r\n      var offsetDescriptionLength = offsetMime + mimeLength;\r\n      var descriptionLength = data.getLongAt(offsetDescriptionLength, true);\r\n      var offsetDescription = offsetDescriptionLength + 4;\r\n      var description = data.getStringWithCharsetAt(offsetDescription, descriptionLength, \"utf-8\").toString();\r\n      var offsetDataLength = offsetDescription + descriptionLength + 16;\r\n      var dataLength = data.getLongAt(offsetDataLength, true);\r\n      var offsetData = offsetDataLength + 4;\r\n      var imageData = data.getBytesAt(offsetData, dataLength, true);\r\n      picture = {\r\n        format: mime,\r\n        type: IMAGE_TYPES[imageType],\r\n        description: description,\r\n        data: imageData\r\n      }\r\n    }\r\n    \r\n    var tag = {\r\n      type: \"FLAC\",\r\n      version: \"1\",\r\n      tags: {\r\n        \"title\": title,\r\n        \"artist\": artist,\r\n        \"album\": album,\r\n        \"track\": track,\r\n        \"genre\": genre,\r\n        \"picture\": picture\r\n      }\r\n    }\r\n    return tag;\r\n  }\r\n}\r\n\r\nexport default FLACTagReader;\r\n","const fs = require('fs');\r\n\r\nimport ChunkedFileData from \"./ChunkedFileData\";\r\nimport MediaFileReader from \"./MediaFileReader\";\r\n\r\nimport type { LoadCallbackType } from \"./FlowTypes\";\r\n\r\nclass NodeFileReader extends MediaFileReader {\r\n  _path: string;\r\n  _fileData: ChunkedFileData;\r\n\r\n  constructor(path: string) {\r\n    super();\r\n    this._path = path;\r\n    this._fileData = new ChunkedFileData();\r\n    this._isInitialized = true;\r\n  }\r\n\r\n  static canReadFile(file: any): boolean {\r\n    return (\r\n        typeof file === 'string' &&\r\n        !/^[a-z]+:\\/\\//i.test(file)\r\n      );\r\n  }\r\n\r\n  init(callbacks: LoadCallbackType) {\r\n    var self = this;\r\n\r\n    fs.stat(self._path, function(err : Error, stats : any) {\r\n      if (err) {\r\n        if (callbacks.onError) {\r\n          callbacks.onError({\"type\": \"fs\", \"info\": err});\r\n        }\r\n      } else {\r\n        self._size = stats.size;\r\n        callbacks.onSuccess();\r\n      }\r\n    });\r\n  }\r\n\r\n  loadRange(range: [number, number], callbacks: LoadCallbackType) {\r\n    var fd = -1;\r\n    var self = this;\r\n    var fileData = this._fileData;\r\n\r\n    var length = range[1] - range[0] + 1;\r\n    var onSuccess = callbacks.onSuccess;\r\n    var onError = callbacks.onError || function(object){};\r\n\r\n    if (fileData.hasDataRange(range[0], range[1])) {\r\n      process.nextTick(onSuccess);\r\n      return;\r\n    }\r\n\r\n    var readData = function(err : Error, _fd : number) {\r\n      if (err) {\r\n        onError({\"type\": \"fs\", \"info\": err});\r\n        return;\r\n      }\r\n\r\n      fd = _fd;\r\n      // TODO: Should create a pool of Buffer objects across all instances of\r\n      //       NodeFileReader. This is fine for now.\r\n      var buffer = Buffer.alloc(length);\r\n      fs.read(_fd, buffer, 0, length, range[0], processData);\r\n    };\r\n\r\n    var processData = function(err: Error, bytesRead : any, buffer: Buffer) {\r\n      fs.close(fd, function(err: Error) {\r\n        if (err) {\r\n          console.error(err);\r\n        }\r\n      });\r\n\r\n      if (err) {\r\n        onError({\"type\": \"fs\", \"info\": err});\r\n        return;\r\n      }\r\n\r\n      storeBuffer(buffer);\r\n      onSuccess();\r\n    };\r\n\r\n    var storeBuffer = function(buffer: Buffer) {\r\n      var data = Array.prototype.slice.call(buffer, 0, length);\r\n      fileData.addData(range[0], data);\r\n    }\r\n\r\n    fs.open(this._path, \"r\", undefined, readData);\r\n  }\r\n\r\n  getByteAt(offset: number): number {\r\n    return this._fileData.getByteAt(offset);\r\n  }\r\n}\r\n\r\nexport default NodeFileReader;\r\n","import MediaFileReader from \"./MediaFileReader\";\r\nimport XhrFileReader from \"./XhrFileReader\";\r\nimport BlobFileReader from \"./BlobFileReader\";\r\nimport ArrayFileReader from \"./ArrayFileReader\";\r\nimport MediaTagReader from \"./MediaTagReader\";\r\nimport ID3v1TagReader from \"./ID3v1TagReader\";\r\nimport ID3v2TagReader from \"./ID3v2TagReader\";\r\nimport MP4TagReader from \"./MP4TagReader\";\r\nimport FLACTagReader from \"./FLACTagReader\";\r\nimport NodeFileReader from './NodeFileReader';\r\n\r\nimport type { CallbackType, LoadCallbackType, ByteRange } from \"./FlowTypes\";\r\n\r\nvar mediaFileReaders: Array<MediaFileReader> = [];\r\nvar mediaTagReaders: Array<MediaTagReader> = [];\r\n\r\nexport function read(location: Object, callbacks: CallbackType) {\r\n  new Reader(location).read(callbacks);\r\n}\r\n\r\nfunction isRangeValid(range: ByteRange, fileSize: number) {\r\n  const invalidPositiveRange =\r\n    range.offset >= 0 && range.offset + range.length >= fileSize;\r\n\r\n  const invalidNegativeRange =\r\n    range.offset < 0 &&\r\n    (-range.offset > fileSize || range.offset + range.length > 0);\r\n\r\n  return !(invalidPositiveRange || invalidNegativeRange);\r\n}\r\n\r\nexport class Reader {\r\n  _file: any;\r\n  _tagsToRead: Array<string>;\r\n  _fileReader: MediaFileReader;\r\n  _tagReader: MediaTagReader;\r\n\r\n  constructor(file: any) {\r\n    this._file = file;\r\n  }\r\n\r\n  setTagsToRead(tagsToRead: Array<string>): Reader {\r\n    this._tagsToRead = tagsToRead;\r\n    return this;\r\n  }\r\n\r\n  setFileReader(fileReader: MediaFileReader): Reader {\r\n    this._fileReader = fileReader;\r\n    return this;\r\n  }\r\n\r\n  setTagReader(tagReader: MediaTagReader): Reader {\r\n    this._tagReader = tagReader;\r\n    return this;\r\n  }\r\n\r\n  read(callbacks: CallbackType) {\r\n    var FileReader = this._getFileReader();\r\n    var fileReader = new FileReader(this._file);\r\n    var self = this;\r\n\r\n    fileReader.init({\r\n      onSuccess: function () {\r\n        self._getTagReader(fileReader, {\r\n          onSuccess: function (TagReader: MediaTagReader) {\r\n            new TagReader(fileReader)\r\n              .setTagsToRead(self._tagsToRead)\r\n              .read(callbacks);\r\n          },\r\n          onError: callbacks.onError,\r\n        });\r\n      },\r\n      onError: callbacks.onError,\r\n    });\r\n  }\r\n\r\n  _getFileReader(): MediaFileReader {\r\n    if (this._fileReader) {\r\n      return this._fileReader;\r\n    } else {\r\n      return this._findFileReader();\r\n    }\r\n  }\r\n\r\n  _findFileReader(): MediaFileReader {\r\n    for (var i = 0; i < mediaFileReaders.length; i++) {\r\n      if (mediaFileReaders[i].canReadFile(this._file)) {\r\n        return mediaFileReaders[i];\r\n      }\r\n    }\r\n\r\n    throw new Error(\"No suitable file reader found for \" + this._file);\r\n  }\r\n\r\n  _getTagReader(fileReader: MediaFileReader, callbacks: CallbackType) {\r\n    if (this._tagReader) {\r\n      var tagReader = this._tagReader;\r\n      setTimeout(function () {\r\n        callbacks.onSuccess(tagReader);\r\n      }, 1);\r\n    } else {\r\n      this._findTagReader(fileReader, callbacks);\r\n    }\r\n  }\r\n\r\n  _findTagReader(fileReader: MediaFileReader, callbacks: CallbackType) {\r\n    // We don't want to make multiple fetches per tag reader to get the tag\r\n    // identifier. The strategy here is to combine all the tag identifier\r\n    // ranges into one and make a single fetch. This is particularly important\r\n    // in file readers that have expensive loads like the XHR one.\r\n    // However, with this strategy we run into the problem of loading the\r\n    // entire file because tag identifiers might be at the start or end of\r\n    // the file.\r\n    // To get around this we divide the tag readers into two categories, the\r\n    // ones that read their tag identifiers from the start of the file and the\r\n    // ones that read from the end of the file.\r\n    var tagReadersAtFileStart = [];\r\n    var tagReadersAtFileEnd = [];\r\n    var fileSize = fileReader.getSize();\r\n\r\n    for (var i = 0; i < mediaTagReaders.length; i++) {\r\n      var range = mediaTagReaders[i].getTagIdentifierByteRange();\r\n      if (!isRangeValid(range, fileSize)) {\r\n        continue;\r\n      }\r\n\r\n      if (\r\n        (range.offset >= 0 && range.offset < fileSize / 2) ||\r\n        (range.offset < 0 && range.offset < -fileSize / 2)\r\n      ) {\r\n        tagReadersAtFileStart.push(mediaTagReaders[i]);\r\n      } else {\r\n        tagReadersAtFileEnd.push(mediaTagReaders[i]);\r\n      }\r\n    }\r\n\r\n    var tagsLoaded = false;\r\n    var loadTagIdentifiersCallbacks = {\r\n      onSuccess: function () {\r\n        if (!tagsLoaded) {\r\n          // We're expecting to load two sets of tag identifiers. This flag\r\n          // indicates when the first one has been loaded.\r\n          tagsLoaded = true;\r\n          return;\r\n        }\r\n\r\n        for (var i = 0; i < mediaTagReaders.length; i++) {\r\n          var range = mediaTagReaders[i].getTagIdentifierByteRange();\r\n          if (!isRangeValid(range, fileSize)) {\r\n            continue;\r\n          }\r\n\r\n          try {\r\n            var tagIndentifier = fileReader.getBytesAt(\r\n              range.offset >= 0 ? range.offset : range.offset + fileSize,\r\n              range.length\r\n            );\r\n          } catch (ex) {\r\n            if (callbacks.onError) {\r\n              callbacks.onError({\r\n                type: \"fileReader\",\r\n                info: ex.message,\r\n              });\r\n            }\r\n            return;\r\n          }\r\n\r\n          if (mediaTagReaders[i].canReadTagFormat(tagIndentifier)) {\r\n            callbacks.onSuccess(mediaTagReaders[i]);\r\n            return;\r\n          }\r\n        }\r\n\r\n        if (callbacks.onError) {\r\n          callbacks.onError({\r\n            type: \"tagFormat\",\r\n            info: \"No suitable tag reader found\",\r\n          });\r\n        }\r\n      },\r\n      onError: callbacks.onError,\r\n    };\r\n\r\n    this._loadTagIdentifierRanges(\r\n      fileReader,\r\n      tagReadersAtFileStart,\r\n      loadTagIdentifiersCallbacks\r\n    );\r\n    this._loadTagIdentifierRanges(\r\n      fileReader,\r\n      tagReadersAtFileEnd,\r\n      loadTagIdentifiersCallbacks\r\n    );\r\n  }\r\n\r\n  _loadTagIdentifierRanges(\r\n    fileReader: MediaFileReader,\r\n    tagReaders: Array<MediaTagReader>,\r\n    callbacks: LoadCallbackType\r\n  ) {\r\n    if (tagReaders.length === 0) {\r\n      // Force async\r\n      setTimeout(callbacks.onSuccess, 1);\r\n      return;\r\n    }\r\n\r\n    var tagIdentifierRange = [Number.MAX_VALUE, 0];\r\n    var fileSize = fileReader.getSize();\r\n\r\n    // Create a super set of all ranges so we can load them all at once.\r\n    // Might need to rethink this approach if there are tag ranges too far\r\n    // a part from each other. We're good for now though.\r\n    for (var i = 0; i < tagReaders.length; i++) {\r\n      var range = tagReaders[i].getTagIdentifierByteRange();\r\n      var start = range.offset >= 0 ? range.offset : range.offset + fileSize;\r\n      var end = start + range.length - 1;\r\n\r\n      tagIdentifierRange[0] = Math.min(start, tagIdentifierRange[0]);\r\n      tagIdentifierRange[1] = Math.max(end, tagIdentifierRange[1]);\r\n    }\r\n\r\n    fileReader.loadRange(tagIdentifierRange, callbacks);\r\n  }\r\n}\r\n\r\nexport class Config {\r\n  static addFileReader(fileReader: MediaFileReader): Config {\r\n    mediaFileReaders.push(fileReader);\r\n    return Config;\r\n  }\r\n\r\n  static addTagReader(tagReader: MediaTagReader): Config {\r\n    mediaTagReaders.push(tagReader);\r\n    return Config;\r\n  }\r\n\r\n  static removeTagReader(tagReader: MediaTagReader): Config {\r\n    var tagReaderIx = mediaTagReaders.indexOf(tagReader);\r\n\r\n    if (tagReaderIx >= 0) {\r\n      mediaTagReaders.splice(tagReaderIx, 1);\r\n    }\r\n\r\n    return Config;\r\n  }\r\n\r\n  static EXPERIMENTAL_avoidHeadRequests() {\r\n    XhrFileReader.setConfig({\r\n      avoidHeadRequests: true,\r\n    });\r\n  }\r\n\r\n  static setDisallowedXhrHeaders(disallowedXhrHeaders: Array<string>) {\r\n    XhrFileReader.setConfig({\r\n      disallowedXhrHeaders: disallowedXhrHeaders,\r\n    });\r\n  }\r\n\r\n  static setXhrTimeoutInSec(timeoutInSec: number) {\r\n    XhrFileReader.setConfig({\r\n      timeoutInSec: timeoutInSec,\r\n    });\r\n  }\r\n}\r\n\r\nConfig.addFileReader(XhrFileReader)\r\n  .addFileReader(BlobFileReader)\r\n  .addFileReader(ArrayFileReader)\r\n  .addTagReader(ID3v2TagReader)\r\n  .addTagReader(ID3v1TagReader)\r\n  .addTagReader(MP4TagReader)\r\n  .addTagReader(FLACTagReader);\r\n\r\n  if (typeof process !== \"undefined\" && !process.browser) {\r\n    if (typeof navigator !== \"undefined\" && navigator.product === \"ReactNative\") {\r\n      throw new Error('ReactNative not supported');\r\n    } else {\r\n      Config.addFileReader(NodeFileReader);\r\n    }\r\n  }"],"names":["NOT_FOUND","ChunkedFileData","this","_fileData","_proto","prototype","addData","offset","data","offsetEnd","length","chunkRange","_getChunkRange","startIx","splice","insertIx","firstChunk","lastChunk","endIx","needsPrepend","needsAppend","chunk","Math","min","slicedData","_sliceData","_concatData","dataA","dataB","ArrayBuffer","isView","dataAandB","constructor","set","concat","begin","end","slice","subarray","offsetStart","startChunkIx","endChunkIx","i","chunkOffsetEnd","chunkOffsetStart","hasDataRange","getByteAt","dataChunk","dataChunkStart","Error","key","get","InternalDecodedString","value","bytesReadCount","_value","toString","StringUtils","bytes","maxBytes","arr","byte1","String","fromCharCode","join","MediaFileReader","_isInitialized","_size","canReadFile","file","init","callbacks","self","_init","onSuccess","onError","setTimeout","loadRange","range","getSize","getBytesAt","Array","isBitSetAt","bit","getSByteAt","iByte","getShortAt","isBigEndian","iShort","getSShortAt","iUShort","getLongAt","iByte1","iByte2","iByte3","iByte4","iLong","getSLongAt","iULong","getInteger24At","iInteger","getStringAt","string","j","getStringWithCharsetAt","charset","toLowerCase","bigEndian","ix","offset1","offset2","word1","byte3","byte4","byte2","codepoint","getCharAt","getSynchsafeInteger32At","size1","size2","size3","XhrFileReader","_MediaFileReader","url","_this","call","_url","_inheritsLoose","test","setConfig","config","hasOwnProperty","_config","disallowedXhrHeaders","avoidHeadRequests","_fetchSizeWithGetRequest","_fetchSizeWithHeadRequest","_makeXHRRequest","xhr","contentLength","_parseContentLength","_roundRangeToChunkMultiple","contentRange","_parseContentRange","_getXhrResponseContent","instanceLength","_fetchEntireFile","response","responseText","_getResponseHeader","parseInt","parsedContentRange","match","firstBytePosition","lastBytePosition","newLength","ceil","method","_createXHRObject","open","onXHRLoad","status","type","info","onload","onerror","onreadystatechange","readyState","timeoutInSec","timeout","ontimeout","overrideMimeType","_setRequestHeader","send","headerName","headerValue","indexOf","setRequestHeader","_hasResponseHeader","allResponseHeaders","getAllResponseHeaders","headers","split","headerNames","getResponseHeader","charCodeAt","XMLHttpRequest","BlobFileReader","blob","_blob","Blob","File","size","browserFileReader","FileReader","onloadend","event","intArray","Uint8Array","result","onabort","error","readAsArrayBuffer","ArrayFileReader","array","_array","isArray","Buffer","isBuffer","MediaTagReader","mediaFileReader","_mediaFileReader","_tags","getTagIdentifierByteRange","canReadTagFormat","tagIdentifier","setTagsToRead","tags","read","_loadData","_parseData","ex","message","getShortcuts","_expandShortcutTags","tagsWithShortcuts","tagOrShortcut","shortcuts","ID3v1TagReader","_MediaTagReader","apply","arguments","fileSize","title","artist","album","year","trackFlag","track","version","comment","genreIdx","genre","GENRES","tag","frameReaderFunctions","FRAME_DESCRIPTIONS","BUF","CNT","COM","CRA","CRM","ETC","EQU","GEO","IPL","LNK","MCI","MLL","PIC","POP","REV","RVA","SLT","STC","TAL","TBP","TCM","TCO","TCR","TDA","TDY","TEN","TFT","TIM","TKE","TLA","TLE","TMT","TOA","TOF","TOL","TOR","TOT","TP1","TP2","TP3","TP4","TPA","TPB","TRC","TRD","TRK","TSI","TSS","TT1","TT2","TT3","TXT","TXX","TYE","UFI","ULT","WAF","WAR","WAS","WCM","WCP","WPB","WXX","AENC","APIC","ASPI","CHAP","CTOC","COMM","COMR","ENCR","EQU2","EQUA","ETCO","GEOB","GRID","IPLS","LINK","MCDI","MLLT","OWNE","PRIV","PCNT","POPM","POSS","RBUF","RVA2","RVAD","RVRB","SEEK","SYLT","SYTC","TALB","TBPM","TCOM","TCON","TCOP","TDAT","TDLY","TDRC","TDRL","TDTG","TENC","TEXT","TFLT","TIME","TIPL","TIT1","TIT2","TIT3","TKEY","TLAN","TLEN","TMCL","TMED","TMOO","TOAL","TOFN","TOLY","TOPE","TORY","TOWN","TPE1","TPE2","TPE3","TPE4","TPOS","TPRO","TPUB","TRCK","TRDA","TRSN","TRSO","TSOA","TSOP","TSOT","TSIZ","TSRC","TSSE","TSST","TYER","TXXX","UFID","USER","USLT","WCOM","WCOP","WOAF","WOAR","WOAS","WORS","WPAY","WPUB","WXXX","ID3v2FrameReader","getFrameReaderFunction","frameId","readFrames","id3header","frames","frameHeaderSize","_getFrameHeaderSize","header","_readFrameHeader","id","flags","frameSize","frameDataOffset","headerSize","frameData","format","unsynchronisation","getUnsyncFileReader","data_length_indicator","readFrameFunc","parsedData","frame","description","_getFrameDescription","push","major","_readFrameFlags","tag_alter_preservation","file_alter_preservation","read_only","grouping_identity","compression","encryption","getTextEncoding","bite","getUserDefinedFields","userDesc","userDefinedData","user_description","start","PICTURE_TYPE","desc","originalOffset","startTime","endTime","startOffset","endOffset","subFrames","childElementIds","undefined","topLevel","ordered","entryCount","childId","language","shortdesc","text","short_description","replace","descriptor","lyrics","ownerIdentifier","identifier","ID3v2TagReader","revision","unsynch","xheader","xindicator","id3","extended_header","experimental_indicator","footer_present","expandedTags","name","SHORTCUTS","_getFrameData","ids","picture","MP4TagReader","_loadAtom","parentAtomFullName","atomSize","isNaN","atomName","_isContainerAtom","atomFullName","_canReadAtom","tagsToRead","_readAtom","ftyp","indent","seek","atomData","_readMeanMetadataAtom","_readMetadataAtom","klass","TYPES","total","disk","dataStart","METADATA_HEADER","dataLength","ATOM_DESCRIPTIONS","parentAtomName","atomOffset","aART","gnre","trkn","cprt","covr","keyw","tmpo","cpil","tvsh","tven","tvsn","tves","tvnn","ldes","sonm","soar","soaa","soco","sosn","purd","pcst","purl","catg","hdvd","stik","rtng","pgap","apID","sfID","atID","cnID","plID","geID","flvr","COMMENT_HEADERS","PICTURE_HEADERS","IMAGE_TYPES","FLACTagReader","_len","args","_key","_commentOffset","_pictureOffset","_loadBlock","blockHeader","blockSize","offsetMetadata","_nextBlock","offsetList","numComments","dataOffset","s","d","toUpperCase","imageType","offsetMimeLength","mimeLength","offsetMime","mime","offsetDescriptionLength","descriptionLength","offsetDescription","offsetDataLength","imageData","fs","require","NodeFileReader","path","_path","stat","err","stats","fd","fileData","object","process","nextTick","processData","bytesRead","buffer","close","console","storeBuffer","_fd","alloc","mediaFileReaders","mediaTagReaders","isRangeValid","Reader","_file","_tagsToRead","_fileReader","_tagReader","setFileReader","fileReader","setTagReader","tagReader","_getFileReader","_getTagReader","TagReader","_findFileReader","_findTagReader","tagReadersAtFileStart","tagReadersAtFileEnd","tagsLoaded","loadTagIdentifiersCallbacks","tagIndentifier","_loadTagIdentifierRanges","tagReaders","tagIdentifierRange","Number","MAX_VALUE","max","Config","addFileReader","addTagReader","removeTagReader","tagReaderIx","EXPERIMENTAL_avoidHeadRequests","setDisallowedXhrHeaders","setXhrTimeoutInSec","browser","navigator","product","location"],"mappings":"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"}